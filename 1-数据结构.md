# 数据结构

## ST 表

+ 一维

```cpp
class Sparcetable {
    vector<vector<int> > st;
    int siz;
    bool MX_flg = 0;
    inline int renew(int x, int y) {
        if (MX_flg) return  max(x, y);
        return min(x, y);
    }
public:
    // 注意bhpos(0)返回-1
    bool (*comp)(int, int);
    Sparcetable():siz(maxn) {st.resize(hbpos(maxn - 1) + 1, std::vector<int> (maxn));}
    Sparcetable(const std::vector<int>& a, bool _MX_flg = 1): siz(a.size()), MX_flg(_MX_flg) {
        int n = a.size();
        st.resize(hbpos(n) + 1, vector<int> (n + 1));
        for (int i = 1; i <= n; ++i) st[0][i] = a[i];
        for (int i = 1; i <= hbpos(siz); ++i) {
            for (int j = 1; j + (1 << i) <= siz + 1; ++j) {
                st[i][j] = renew(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);
            }
        }
    }
    int query(int l, int r) {
        int len = hbpos(r - l + 1);
        return renew(st[len][l], st[len][r - (1 << len) + 1]);
    }
};

```

+ 二维

```cpp
int f[10][10][maxn][maxn];
#define _highbit(x) (31 - __builtin_clz(x))
inline int calc(int x, int y, int xx, int yy, int p, int q) {
    return max(
        max(f[p][q][x][y], f[p][q][xx - (1 << p) + 1][yy - (1 << q) + 1]),
        max(f[p][q][xx - (1 << p) + 1][y], f[p][q][x][yy - (1 << q) + 1])
    );
}
void init() {
    for (int x = 0; x <= _highbit(n); ++x)
    for (int y = 0; y <= _highbit(m); ++y)
        for (int i = 0; i <= n - (1 << x); ++i)
        for (int j = 0; j <= m - (1 << y); ++j) {
            if (!x && !y) { f[x][y][i][j] = a[i][j]; continue; }
            f[x][y][i][j] = calc(
                i, j,
                i + (1 << x) - 1, j + (1 << y) - 1,
                max(x - 1, 0), max(y - 1, 0)
            );
        }
}
inline int get_max(int x, int y, int xx, int yy) {
    return calc(x, y, xx, yy, _highbit(xx - x + 1), _highbit(yy - y + 1));
}
```

## Fenwick Tree(树状数组)

+ 一维

```cpp
template<typename T>
class FenwickT {
    int n;
    vector<T> tr;
public:
    FenwickT(int siz): tr(siz), n(siz) {}
    FenwickT(int siz, T ini): tr(siz, ini), n(siz) {}
    void add(int p, T x) {
        for (int i = p; i < n; i += i & (-i)) tr[i] += x;
    }
    T query(int p) {
        T ret = T(0);
        for (int i = p; i > 0; i -= i & (-i)) ret += tr[i];
        return ret;
    }
    T range_sum(int l, int r) {
        return (query(r) - query(l - 1));
    }
    int kth(T k) {
        int x = 0;
        for (int i = 1 << std::__lg(n); i; i /= 2) {
            if (x + i <= n && k >= a[x + i - 1]) {
                x += i;
                k -= a[x - 1];
            }
        }
        return x;
    }
};
```

## 并查集

```cpp
class DSU {
    std::vector<int> fa, siz;
public:
    DSU(int n): fa(n), siz(n, 1) {std::iota(fa.begin(), fa.end(), 0);}
    int findfa(int x) {
        int rt = x;
        while (rt != fa[rt]) rt = fa[rt];
        for (int i = x; i != rt; i = x) {
            siz[i] -= siz[x];
            x = fa[i], fa[i] = rt;
        }
        return rt;
    }
    bool merge(int x, int y) {
        x = findfa(x), y = findfa(y);
        if (x == y) return false;
        if (siz[x] > siz[y]) 
            fa[y] = x, siz[x] += siz[y];
        else 
            fa[x] = y, siz[y] += siz[x];
        return true;
    }
    bool same(int x, int y) { return findfa(x) == findfa(y); }
    int size(int x) { return siz[findfa(x)]; }
};
```


## 线段树

```cpp
class SegT{
    struct Pt{
        int val, ls, rs, sl; 
        Pt():val(0), ls(0), rs(0), sl(0) {}
        Pt(int v, int l, int r, int s): val(v), ls(l), rs(r), sl(s) {}
        ~Pt() {}
    };
    int renew(int x, int y) {
        return x + y;
    }
    int renewsl(int x, int y) {
        return x + y;
    }
    int renewqj(int x, int y, int l, int r) {
        return x + y * (r - l + 1);
    }
public:
    std::vector<Pt> tr;
    int cnt = 0; // 结点数目
    SegT() {cnt = 1; tr.emplace_back();} // 建一棵空树
  
    // 修改
    void add(int l, int r, int p, int ql, int qr, int x) {
        if (ql <= l && r <= qr) {
            tr[p].val = renewqj(tr[p].val, x, l, r);
            tr[p].sl = renewsl(tr[p].sl, x);
            return;
        }
        int mid = l + (r - l) / 2;
        if (tr[p].sl) {
            if (!tr[p].ls) tr[p].ls = cnt++;
            if (!tr[p].rs) tr[p].rs = cnt++;
            if (cnt >= tr.size()) tr.resize(cnt + 1);
            int ls = tr[p].ls, rs = tr[p].rs;
            tr[ls].val = renewqj(tr[ls].val, tr[p].sl, l, mid), tr[rs].val = renewqj(tr[rs].val, tr[p].sl, mid + 1, r);
            tr[ls].sl = renewsl(tr[ls].sl, tr[p].sl), tr[rs].sl = renewsl(tr[rs].sl, tr[p].sl);
            tr[p].sl = 0;
        }
        if (ql <= mid) {
            if (!tr[p].ls) tr[p].ls = cnt++;
            if (cnt >= tr.size()) tr.resize(cnt + 1);
            add(l, mid, tr[p].ls, ql, qr, x);
        }
        if (qr > mid) {
            if (!tr[p].rs) tr[p].rs = cnt++;
            if (cnt >= tr.size()) tr.resize(cnt + 1);
            add(mid + 1, r, tr[p].rs, ql, qr, x);
        }
        tr[p].val = renew(tr[p].ls? tr[tr[p].ls].val: 0, tr[p].rs? tr[tr[p].rs].val: 0);
    };
  
    // 查询
    int query(int l, int r, int p, int ql, int qr) {
        if (ql <= l && r <= qr) return tr[p].val;
        int mid = l + (r - l) / 2;
        if (tr[p].sl) {
            if (!tr[p].ls) tr[p].ls = cnt++;
            if (!tr[p].rs) tr[p].rs = cnt++;
            if (cnt >= tr.size()) tr.resize(cnt + 1);
            int ls = tr[p].ls, rs = tr[p].rs;
            tr[ls].val = renewqj(tr[ls].val, tr[p].sl, l, mid), tr[rs].val = renewqj(tr[rs].val, tr[p].sl, mid + 1, r);
            tr[ls].sl = renewsl(tr[ls].sl, tr[p].sl), tr[rs].sl = renewsl(tr[rs].sl, tr[p].sl);
            tr[p].sl = 0;
        }
        int ret = 0;
        if (ql <= mid) {
            if (!tr[p].ls) tr[p].ls = cnt++;
            if (cnt >= tr.size()) tr.resize(cnt + 1);
            ret = renew(ret, query(l, mid, tr[p].ls, ql, qr));
        }
        if (qr > mid) {
            if (!tr[p].rs) tr[p].rs = cnt++;
            if (cnt >= tr.size()) tr.resize(cnt + 1);
            ret = renew(ret, query(mid + 1, r, tr[p].rs, ql, qr));
        }
        tr[p].val = renew(tr[p].ls? tr[tr[p].ls].val: 0, tr[p].rs? tr[tr[p].rs].val: 0);
        return ret;
    };
};

// 静态线段树
template<class Info,
    class Merge = std::plus<Info> >
struct SegmentTree {
    const int n;
    const Merge merge;
    std::vector<Info> info;
    SegmentTree(int n) : n(n), merge(Merge()), info(4 << std::__lg(n)) {}
    SegmentTree(std::vector<Info> init) : SegmentTree(init.size()) {
        std::function<void(int, int, int)> build = [&](int p, int l, int r) {
            if (r - l == 1) {
                info[p] = init[l];
                return;
            }
            int m = (l + r) / 2;
            build(2 * p, l, m);
            build(2 * p + 1, m, r);
            pull(p);
        };
        build(1, 0, n);
    }
    void pull(int p) {
        info[p] = merge(info[2 * p], info[2 * p + 1]);
    }
    void modify(int p, int l, int r, int x, const Info &v) {
        if (r - l == 1) {
            info[p] = v;
            return;
        }
        int m = (l + r) / 2;
        if (x < m) {
            modify(2 * p, l, m, x, v);
        } else {
            modify(2 * p + 1, m, r, x, v);
        }
        pull(p);
    }
    void modify(int p, const Info &v) {
        modify(1, 0, n, p, v);
    }
    Info rangeQuery(int p, int l, int r, int x, int y) {
        if (l >= y || r <= x) {
            return Info();
        }
        if (l >= x && r <= y) {
            return info[p];
        }
        int m = (l + r) / 2;
        return merge(rangeQuery(2 * p, l, m, x, y), rangeQuery(2 * p + 1, m, r, x, y));
    }
    Info rangeQuery(int l, int r) {
        return rangeQuery(1, 0, n, l, r);
    }
};
```

## 主席树

> 可持久化线段树, 感觉主要是利用单点log次的性质以及离散化的思路. 比如区间第k小就是构造n个线段树(每多加一个实际上只多加了log个点), 然后再用离散化的点(实际上就是其排名值)找到前缀和之差为k(此时为第k小, 可以这样想: 第r棵树的r个点中包含了第l-1棵树的l-1个点, 减掉那些点, 剩下的就是区间[l, r]的点, 然后找第k个)的点.
> 用离线不那么方便. 代码暂时先留空了...


## Trie

```cpp
template<typename T>
struct Trie {
    struct Node {
        T val;  
        int to[2];
        Node(): val{0} {memset(to, 0, sizeof(to));}
        Node(T v): val(v) {memset(to, 0, sizeof(to));}
    };
    std::vector<Node> a;
    int cnt;
    Trie(): a(1), cnt(1) {}
    Trie(int siz): a(siz), cnt(1) {}
    int at(char ch) {return ch - '0';}
    Node& operator [](int idx) {return a[idx];}
    int go(int cur, char ch) {
        int &stat = a[cur].to[at(ch)];
        if (stat == 0) {
            stat = cnt++;
            while (cnt > a.size()) a.emplace_back();
        }
        return a[cur].to[at(ch)];
    }
};

```
