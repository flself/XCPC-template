# 数据结构

## ST 表

+ 一维

```cpp
class Sparcetable {
    vector<vector<int> > st;
    int siz;
    bool MX_flg = 0;
    inline int renew(int x, int y) {
        if (MX_flg) return  max(x, y);
        return min(x, y);
    }
public:
    // 注意bhpos(0)返回-1
    bool (*comp)(int, int);
    Sparcetable():siz(maxn) {st.resize(hbpos(maxn - 1) + 1, std::vector<int> (maxn));}
    Sparcetable(const std::vector<int>& a, bool _MX_flg = 1): siz(a.size()), MX_flg(_MX_flg) {
        int n = a.size();
        st.resize(hbpos(n) + 1, vector<int> (n + 1));
        for (int i = 1; i <= n; ++i) st[0][i] = a[i];
        for (int i = 1; i <= hbpos(siz); ++i) {
            for (int j = 1; j + (1 << i) <= siz + 1; ++j) {
                st[i][j] = renew(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);
            }
        }
    }
    int query(int l, int r) {
        int len = hbpos(r - l + 1);
        return renew(st[len][l], st[len][r - (1 << len) + 1]);
    }
};

```

+ 二维

```cpp
int f[10][10][maxn][maxn];
#define _highbit(x) (31 - __builtin_clz(x))
inline int calc(int x, int y, int xx, int yy, int p, int q) {
    return max(
        max(f[p][q][x][y], f[p][q][xx - (1 << p) + 1][yy - (1 << q) + 1]),
        max(f[p][q][xx - (1 << p) + 1][y], f[p][q][x][yy - (1 << q) + 1])
    );
}
void init() {
    for (int x = 0; x <= _highbit(n); ++x)
    for (int y = 0; y <= _highbit(m); ++y)
        for (int i = 0; i <= n - (1 << x); ++i)
        for (int j = 0; j <= m - (1 << y); ++j) {
            if (!x && !y) { f[x][y][i][j] = a[i][j]; continue; }
            f[x][y][i][j] = calc(
                i, j,
                i + (1 << x) - 1, j + (1 << y) - 1,
                max(x - 1, 0), max(y - 1, 0)
            );
        }
}
inline int get_max(int x, int y, int xx, int yy) {
    return calc(x, y, xx, yy, _highbit(xx - x + 1), _highbit(yy - y + 1));
}
```

## Fenwick Tree(树状数组)

+ 一维

```cpp
template<typename T>
class FenwickT {
    int n;
    vector<T> tr;
public:
    FenwickT(int siz): tr(siz), n(siz) {}
    FenwickT(int siz, T ini): tr(siz, ini), n(siz) {}
    void add(int p, T x) {
        for (int i = p; i < n; i += i & (-i)) tr[i] += x;
    }
    T query(int p) {
        T ret = T(0);
        for (int i = p; i > 0; i -= i & (-i)) ret += tr[i];
        return ret;
    }
    T range_sum(int l, int r) {
        return (query(r) - query(l - 1));
    }
};
```

## 线段树

```cpp
class SegT{
    struct Pt{
        int val, ls, rs, sl; 
        Pt():val(0), ls(0), rs(0), sl(0) {}
        Pt(int v, int l, int r, int s): val(v), ls(l), rs(r), sl(s) {}
        ~Pt() {}
    };
    int renew(int x, int y) {
        return x + y;
    }
    int renewsl(int x, int y) {
        return x + y;
    }
    int renewqj(int x, int y, int l, int r) {
        return x + y * (r - l + 1);
    }
public:
    std::vector<Pt> tr;
    int cnt = 0; // 结点数目
    SegT() {cnt = 1; tr.emplace_back();} // 建一棵空树
    
    // 修改
    void add(int l, int r, int p, int ql, int qr, int x) {
        if (ql <= l && r <= qr) {
            tr[p].val = renewqj(tr[p].val, x, l, r);
            tr[p].sl = renewsl(tr[p].sl, x);
            return;
        }
        int mid = l + (r - l) / 2;
        if (tr[p].sl) {
            if (!tr[p].ls) tr[p].ls = cnt++;
            if (!tr[p].rs) tr[p].rs = cnt++;
            if (cnt >= tr.size()) tr.resize(cnt + 1);
            int ls = tr[p].ls, rs = tr[p].rs;
            tr[ls].val = renewqj(tr[ls].val, tr[p].sl, l, mid), tr[rs].val = renewqj(tr[rs].val, tr[p].sl, mid + 1, r);
            tr[ls].sl = renewsl(tr[ls].sl, tr[p].sl), tr[rs].sl = renewsl(tr[rs].sl, tr[p].sl);
            tr[p].sl = 0;
        }
        if (ql <= mid) {
            if (!tr[p].ls) tr[p].ls = cnt++;
            if (cnt >= tr.size()) tr.resize(cnt + 1);
            add(l, mid, tr[p].ls, ql, qr, x);
        }
        if (qr > mid) {
            if (!tr[p].rs) tr[p].rs = cnt++;
            if (cnt >= tr.size()) tr.resize(cnt + 1);
            add(mid + 1, r, tr[p].rs, ql, qr, x);
        }
        tr[p].val = renew(tr[p].ls? tr[tr[p].ls].val: 0, tr[p].rs? tr[tr[p].rs].val: 0);
    };
    
    // 查询
    int query(int l, int r, int p, int ql, int qr) {
        if (ql <= l && r <= qr) return tr[p].val;
        int mid = l + (r - l) / 2;
        if (tr[p].sl) {
            if (!tr[p].ls) tr[p].ls = cnt++;
            if (!tr[p].rs) tr[p].rs = cnt++;
            if (cnt >= tr.size()) tr.resize(cnt + 1);
            int ls = tr[p].ls, rs = tr[p].rs;
            tr[ls].val = renewqj(tr[ls].val, tr[p].sl, l, mid), tr[rs].val = renewqj(tr[rs].val, tr[p].sl, mid + 1, r);
            tr[ls].sl = renewsl(tr[ls].sl, tr[p].sl), tr[rs].sl = renewsl(tr[rs].sl, tr[p].sl);
            tr[p].sl = 0;
        }
        int ret = 0;
        if (ql <= mid) {
            if (!tr[p].ls) tr[p].ls = cnt++;
            if (cnt >= tr.size()) tr.resize(cnt + 1);
            ret = renew(ret, query(l, mid, tr[p].ls, ql, qr));
        }
        if (qr > mid) {
            if (!tr[p].rs) tr[p].rs = cnt++;
            if (cnt >= tr.size()) tr.resize(cnt + 1);
            ret = renew(ret, query(mid + 1, r, tr[p].rs, ql, qr));
        }
        tr[p].val = renew(tr[p].ls? tr[tr[p].ls].val: 0, tr[p].rs? tr[tr[p].rs].val: 0);
        return ret;
    };
};
```

## 主席树

> 可持久化线段树, 感觉主要是利用单点log次的性质以及离散化的思路. 比如区间第k小就是构造n个线段树(每多加一个实际上只多加了log个点), 然后再用离散化的点(实际上就是其排名值)找到前缀和之差为k(此时为第k小, 可以这样想: 第r棵树的r个点中包含了第l-1棵树的l-1个点, 减掉那些点, 剩下的就是区间[l, r]的点, 然后找第k个)的点.
> 用离线不那么方便. 代码暂时先留空了...

