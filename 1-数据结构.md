# 数据结构

## ST 表

+ 一维

```cpp
class Sparcetable {
    vector<vector<int> > st;
    int siz;
    bool MX_flg = 0;
    inline int renew(int x, int y) {
        if (MX_flg) return  max(x, y);
        return min(x, y);
    }
public:
    // 注意bhpos(0)返回-1
    bool (*comp)(int, int);
    Sparcetable():siz(maxn) {st.resize(hbpos(maxn - 1) + 1, std::vector<int> (maxn));}
    Sparcetable(const std::vector<int>& a, bool _MX_flg = 1): siz(a.size()), MX_flg(_MX_flg) {
        int n = a.size();
        st.resize(hbpos(n) + 1, vector<int> (n + 1));
        for (int i = 1; i <= n; ++i) st[0][i] = a[i];
        for (int i = 1; i <= hbpos(siz); ++i) {
            for (int j = 1; j + (1 << i) <= siz + 1; ++j) {
                st[i][j] = renew(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);
            }
        }
    }
    int query(int l, int r) {
        int len = hbpos(r - l + 1);
        return renew(st[len][l], st[len][r - (1 << len) + 1]);
    }
};

```

+ 二维

```cpp
int f[10][10][maxn][maxn];
#define _highbit(x) (31 - __builtin_clz(x))
inline int calc(int x, int y, int xx, int yy, int p, int q) {
    return max(
        max(f[p][q][x][y], f[p][q][xx - (1 << p) + 1][yy - (1 << q) + 1]),
        max(f[p][q][xx - (1 << p) + 1][y], f[p][q][x][yy - (1 << q) + 1])
    );
}
void init() {
    for (int x = 0; x <= _highbit(n); ++x)
    for (int y = 0; y <= _highbit(m); ++y)
        for (int i = 0; i <= n - (1 << x); ++i)
        for (int j = 0; j <= m - (1 << y); ++j) {
            if (!x && !y) { f[x][y][i][j] = a[i][j]; continue; }
            f[x][y][i][j] = calc(
                i, j,
                i + (1 << x) - 1, j + (1 << y) - 1,
                max(x - 1, 0), max(y - 1, 0)
            );
        }
}
inline int get_max(int x, int y, int xx, int yy) {
    return calc(x, y, xx, yy, _highbit(xx - x + 1), _highbit(yy - y + 1));
}
```

## Fenwick Tree(树状数组)

+ 一维

```cpp
template<typename T>
class FenwickT {
    int n;
    vector<T> tr;
public:
    FenwickT(int siz): tr(siz), n(siz) {}
    FenwickT(int siz, T ini): tr(siz, ini), n(siz) {}
    void add(int p, T x) {
        for (int i = p; i < n; i += i & (-i)) tr[i] += x;
    }
    T query(int p) {
        T ret = T(0);
        for (int i = p; i > 0; i -= i & (-i)) ret += tr[i];
        return ret;
    }
    T range_sum(int l, int r) {
        return (query(r) - query(l - 1));
    }
    int kth(T k) {
        int x = 0;
        for (int i = 1 << std::__lg(n); i; i /= 2) {
            if (x + i <= n && k >= a[x + i - 1]) {
                x += i;
                k -= a[x - 1];
            }
        }
        return x;
    }
};
```

## 并查集

```cpp
class DSU {
    std::vector<int> fa, siz;
public:
    DSU(int n): fa(n), siz(n, 1) {std::iota(fa.begin(), fa.end(), 0);}
    int findfa(int x) {
        int rt = x;
        while (rt != fa[rt]) rt = fa[rt];
        for (int i = x; i != rt; i = x) {
            siz[i] -= siz[x];
            x = fa[i], fa[i] = rt;
        }
        return rt;
    }
    bool merge(int x, int y) {
        x = findfa(x), y = findfa(y);
        if (x == y) return false;
        if (siz[x] > siz[y]) 
            fa[y] = x, siz[x] += siz[y];
        else 
            fa[x] = y, siz[y] += siz[x];
        return true;
    }
    bool same(int x, int y) { return findfa(x) == findfa(y); }
    int size(int x) { return siz[findfa(x)]; }
};
```

### 带权并查集

```cpp
class DSU {
    std::vector<int> fa, siz;
    std::vector<int> tag;
public:
    DSU(int n): fa(n), siz(n, 1), tag(n, 0) {std::iota(fa.begin(), fa.end(), 0);}
    int findfa(int x) {
        int rt = x, tg = tag[x];
        while (rt != fa[rt]) rt = fa[rt], tg ^= tag[rt];
        for (int i = x; i != rt; i = x) {
            siz[i] -= siz[x];
            x = fa[i], fa[i] = rt;
            // std::swap(tg, tag[i]); tg ^= tag[i];
            tg ^= tag[i] ^= tg ^= tag[i] ^= tg;
        }
        return rt;
    }
    bool merge(int x, int y, int tg = 0) {
        if (findfa(x) == findfa(y)) {
            if ((tag[x] ^ tag[y]) != tg) return false;
            return true;
        }
        tg ^= tag[x] ^ tag[y];
        x = findfa(x), y = findfa(y);
        if (siz[x] > siz[y]) 
            fa[y] = x, siz[x] += siz[y], tag[y] = tg;
        else 
            fa[x] = y, siz[y] += siz[x], tag[x] = tg;
        return true;
    }
    bool same(int x, int y) { return findfa(x) == findfa(y); }
    int size(int x) { return siz[findfa(x)]; }
};

```


## 线段树

```cpp
class SegT{
    struct Pt{
        int val, ls, rs, sl; 
        Pt():val(0), ls(0), rs(0), sl(0) {}
        Pt(int v, int l, int r, int s): val(v), ls(l), rs(r), sl(s) {}
        ~Pt() {}
    };
    int renew(int x, int y) {
        return x + y;
    }
    int renewsl(int x, int y) {
        return x + y;
    }
    int renewqj(int x, int y, int l, int r) {
        return x + y * (r - l + 1);
    }
public:
    std::vector<Pt> tr;
    int cnt = 0; // 结点数目
    SegT() {cnt = 1; tr.emplace_back();} // 建一棵空树
  
    // 修改
    void add(int l, int r, int p, int ql, int qr, int x) {
        if (ql <= l && r <= qr) {
            tr[p].val = renewqj(tr[p].val, x, l, r);
            tr[p].sl = renewsl(tr[p].sl, x);
            return;
        }
        int mid = l + (r - l) / 2;
        if (tr[p].sl) {
            if (!tr[p].ls) tr[p].ls = cnt++;
            if (!tr[p].rs) tr[p].rs = cnt++;
            if (cnt >= tr.size()) tr.resize(cnt + 1);
            int ls = tr[p].ls, rs = tr[p].rs;
            tr[ls].val = renewqj(tr[ls].val, tr[p].sl, l, mid), tr[rs].val = renewqj(tr[rs].val, tr[p].sl, mid + 1, r);
            tr[ls].sl = renewsl(tr[ls].sl, tr[p].sl), tr[rs].sl = renewsl(tr[rs].sl, tr[p].sl);
            tr[p].sl = 0;
        }
        if (ql <= mid) {
            if (!tr[p].ls) tr[p].ls = cnt++;
            if (cnt >= tr.size()) tr.resize(cnt + 1);
            add(l, mid, tr[p].ls, ql, qr, x);
        }
        if (qr > mid) {
            if (!tr[p].rs) tr[p].rs = cnt++;
            if (cnt >= tr.size()) tr.resize(cnt + 1);
            add(mid + 1, r, tr[p].rs, ql, qr, x);
        }
        tr[p].val = renew(tr[p].ls? tr[tr[p].ls].val: 0, tr[p].rs? tr[tr[p].rs].val: 0);
    };
  
    // 查询
    int query(int l, int r, int p, int ql, int qr) {
        if (ql <= l && r <= qr) return tr[p].val;
        int mid = l + (r - l) / 2;
        if (tr[p].sl) {
            if (!tr[p].ls) tr[p].ls = cnt++;
            if (!tr[p].rs) tr[p].rs = cnt++;
            if (cnt >= tr.size()) tr.resize(cnt + 1);
            int ls = tr[p].ls, rs = tr[p].rs;
            tr[ls].val = renewqj(tr[ls].val, tr[p].sl, l, mid), tr[rs].val = renewqj(tr[rs].val, tr[p].sl, mid + 1, r);
            tr[ls].sl = renewsl(tr[ls].sl, tr[p].sl), tr[rs].sl = renewsl(tr[rs].sl, tr[p].sl);
            tr[p].sl = 0;
        }
        int ret = 0;
        if (ql <= mid) {
            if (!tr[p].ls) tr[p].ls = cnt++;
            if (cnt >= tr.size()) tr.resize(cnt + 1);
            ret = renew(ret, query(l, mid, tr[p].ls, ql, qr));
        }
        if (qr > mid) {
            if (!tr[p].rs) tr[p].rs = cnt++;
            if (cnt >= tr.size()) tr.resize(cnt + 1);
            ret = renew(ret, query(mid + 1, r, tr[p].rs, ql, qr));
        }
        tr[p].val = renew(tr[p].ls? tr[tr[p].ls].val: 0, tr[p].rs? tr[tr[p].rs].val: 0);
        return ret;
    };
};

// 静态线段树
template<class Info,
    class Merge = std::plus<Info> >
struct SegmentTree {
    const int n;
    const Merge merge;
    std::vector<Info> info;
    SegmentTree(int n) : n(n), merge(Merge()), info(4 << std::__lg(n)) {}
    SegmentTree(std::vector<Info> init) : SegmentTree(init.size()) {
        std::function<void(int, int, int)> build = [&](int p, int l, int r) {
            if (r - l == 1) {
                info[p] = init[l];
                return;
            }
            int m = (l + r) / 2;
            build(2 * p, l, m);
            build(2 * p + 1, m, r);
            pull(p);
        };
        build(1, 0, n);
    }
    void pull(int p) {
        info[p] = merge(info[2 * p], info[2 * p + 1]);
    }
    void modify(int p, int l, int r, int x, const Info &v) {
        if (r - l == 1) {
            info[p] = v;
            return;
        }
        int m = (l + r) / 2;
        if (x < m) {
            modify(2 * p, l, m, x, v);
        } else {
            modify(2 * p + 1, m, r, x, v);
        }
        pull(p);
    }
    void modify(int p, const Info &v) {
        modify(1, 0, n, p, v);
    }
    Info rangeQuery(int p, int l, int r, int x, int y) {
        if (l >= y || r <= x) {
            return Info();
        }
        if (l >= x && r <= y) {
            return info[p];
        }
        int m = (l + r) / 2;
        return merge(rangeQuery(2 * p, l, m, x, y), rangeQuery(2 * p + 1, m, r, x, y));
    }
    Info rangeQuery(int l, int r) {
        return rangeQuery(1, 0, n, l, r);
    }
};
```


## 吉如一线段树

区间赋值、区间取min，求和、求最大值、求历史最大值

```cpp
namespace JRY_SegT{
    // namespace JRY_SegT
    // O(n log n) luogu n,m 5e5 max1.62s
    using i64 = long long;
    constexpr i64 INF = 0x7fffffffffffffff;
    struct Info {
        i64 sum,mx,smx,hmx,cnt;
        Info(i64 sum=0,i64 mx=-INF,i64 smx=-INF,i64 hmx=-INF,i64 cnt=0)
            : sum(sum),mx(mx),smx(smx),hmx(hmx),cnt(cnt) {}
    };
    Info merge(Info x,Info y) {
        Info r;
        r.sum = x.sum + y.sum;
        r.mx = std::max(x.mx, y.mx);
        r.hmx = std::max(x.hmx, y.hmx);
        if(x.mx == y.mx) r.smx = std::max(x.smx, y.smx), r.cnt = x.cnt + y.cnt;
        else if(x.mx > y.mx) r.smx = std::max(x.smx, y.mx), r.cnt = x.cnt;
        else r.smx = std::max(x.mx, y.smx), r.cnt = y.cnt;
        return r;
    }
    struct Tag {
        i64 lzm,lzo,hlzm,hlzo;
        Tag() : lzm(0),lzo(0),hlzm(0),hlzo(0) {}
        void clear() {
            lzm = lzo = hlzm = hlzo = 0;
        }
        bool is0() {
            return lzm == 0 && lzo == 0 && hlzm == 0 && hlzo == 0;
        }
    };
    struct SegT {
        int n;
        std::vector<Info> t;
        std::vector<Tag> z;
        std::vector<int> le,ri;
        SegT(int n,const std::vector<i64>&a) : n(n), t(4*n), z(4*n), le(4*n), ri(4*n) {
            build(1,0,n,a);
        }
        void build(int p,int l,int r,const std::vector<i64>&a) {
            le[p] = l, ri[p] = r;
            if(r - l == 1) {
                t[p] = Info(a[l],a[l],-INF,a[l],1);
                return;
            }
            int mid = l + r >> 1;
            build(p << 1, l, mid, a);
            build(p << 1 | 1, mid, r, a);
            pull(p);
        }
        void pull(int p) {
            t[p] = merge(t[p << 1], t[p << 1 | 1]);
        }
        void update(int p,i64 lzm,i64 lzo,i64 hlzm,i64 hlzo) {
            t[p].sum += lzm * t[p].cnt + (ri[p] - le[p] - t[p].cnt) * lzo;
            t[p].hmx = std::max(t[p].hmx, t[p].mx + hlzm);
            t[p].mx += lzm;
            if(t[p].smx != -INF) t[p].smx += lzo;
            z[p].hlzm = std::max(z[p].hlzm, z[p].lzm + hlzm), z[p].lzm += lzm;
            z[p].hlzo = std::max(z[p].hlzo, z[p].lzo + hlzo), z[p].lzo += lzo;
        }
        void pushdown(int p) {
            if(z[p].is0()) return;
            int mx = std::max(t[p << 1].mx, t[p << 1 | 1].mx);
            for(auto ps : {p << 1, p << 1 | 1}) {
                if(t[ps].mx == mx) update(ps, z[p].lzm, z[p].lzo, z[p].hlzm, z[p].hlzo);
                else update(ps, z[p].lzo, z[p].lzo, z[p].hlzo, z[p].hlzo);
            }
            z[p].clear();
        }
        void range_add(int p,int L,int R,i64 v) {
            if(ri[p] <= L || R <= le[p]) return;
            if(L <= le[p] && ri[p] <= R) {
                update(p,v,v,v,v);
                return;
            }
            pushdown(p);
            range_add(p << 1, L, R, v);
            range_add(p << 1 | 1, L, R, v);
            pull(p);
        }
        void range_min(int p,int L,int R,i64 v) {
            if(ri[p] <= L || R <= le[p] || t[p].mx <= v) return;
            if(L <= le[p] && ri[p] <= R && t[p].smx < v) {
                update(p, v - t[p].mx, 0, v - t[p].mx, 0);
                return;
            }
            pushdown(p);
            range_min(p << 1, L, R, v);
            range_min(p << 1 | 1, L, R, v);
            pull(p);
        }
        i64 query_sum(int p,int L,int R) {
            if(ri[p] <= L || R <= le[p]) return 0ll;
            if(L <= le[p] && ri[p] <= R) return t[p].sum;
            pushdown(p);
            return query_sum(p << 1, L, R) + query_sum(p << 1 | 1, L, R);
        }
        i64 query_mx(int p,int L,int R) {
            if(ri[p] <= L || R <= le[p]) return -INF;
            if(L <= le[p] && ri[p] <= R) return t[p].mx;
            pushdown(p);
            return std::max(query_mx(p << 1, L, R), query_mx(p << 1 | 1, L, R));
        }
        i64 query_hmx(int p,int L,int R) {
            if(ri[p] <= L || R <= le[p]) return -INF;
            if(L <= le[p] && ri[p] <= R) return t[p].hmx;
            pushdown(p);
            return std::max(query_hmx(p << 1, L, R), query_hmx(p << 1 | 1, L, R));
        }
    };
};

```



## 主席树

> 可持久化线段树, 感觉主要是利用单点log次的性质以及离散化的思路. 比如区间第k小就是构造n个线段树(每多加一个实际上只多加了log个点), 然后再用离散化的点(实际上就是其排名值)找到前缀和之差为k(此时为第k小, 可以这样想: 第r棵树的r个点中包含了第l-1棵树的l-1个点, 减掉那些点, 剩下的就是区间[l, r]的点, 然后找第k个)的点.
> 用离线不那么方便. 代码暂时先留空了...


## Trie

```cpp
template<typename T>
struct Trie {
    struct Node {
        T val;  
        int to[2];
        Node(): val{0} {memset(to, 0, sizeof(to));}
        Node(T v): val(v) {memset(to, 0, sizeof(to));}
    };
    std::vector<Node> a;
    int cnt;
    Trie(): a(1), cnt(1) {}
    Trie(int siz): a(siz), cnt(1) {}
    int at(char ch) {return ch - '0';}
    Node& operator [](int idx) {return a[idx];}
    int go(int cur, char ch) {
        int &stat = a[cur].to[at(ch)];
        if (stat == 0) {
            stat = cnt++;
            while (cnt > a.size()) a.emplace_back();
        }
        return a[cur].to[at(ch)];
    }
};

```

## 虚树

```cpp
namespace VirtualTree{
    const int N = 1e5+3;
    std::vector<std::pair<int, int> > g[N]; // 原本的树
    int idx[N]; // idx[x] -> 点x的dfs序号
    int ridx[N];// ridx[id] -> dfs序为id的点号
    int dep[N]; // dep[x] -> 点x的深度
    int siz[N]; // siz[x] -> 以点x为根的树的大小
    int top[N]; // top[x] -> 点x所在重链的顶点
    int fa[N];  // fa[x] -> 点x的父亲结点
    int son[N]; // son[x] -> 点x的重儿子
    int clk = 0;// clk -> dfs序号

    void init() {
        for (int i = 0; i <= clk; ++i)
            g[i].clear();
        clk = 0;
    }
    int lca(int u, int v) {
        while (top[u] != top[v]) {
            if (dep[top[u]] < dep[top[v]]) std::swap(u, v);
            u = fa[top[u]];
        }
        if (dep[u] > dep[v]) std::swap(u, v);
        return u;
    }
    void HLDinit(int rt) {
        std::function<void(int, int)> predfs1 = [&](int u, int f) {
            siz[u] = 1;
            int &maxs = son[u] = -1;
            for (auto &[to, w]: g[u]) {
                if (to == f) continue;
                fa[to] = u, dep[to] = dep[u] + 1;
                predfs1(to, u);
                siz[u] += siz[to];
                if (maxs == -1 || siz[to] > siz[maxs]) maxs = to;
            }
        };
        std::function<void(int, int)> predfs2 = [&](int u, int tp) {
            top[u] = tp;
            idx[u] = ++clk, ridx[clk] = u;
            if (son[u] != -1) {
                predfs2(son[u], tp);
            }
            for (auto &[to, w]: g[u]) {
                if (to != fa[u] && to != son[u]) predfs2(to, to);
            }
        };
        predfs1(rt, -1);
        predfs2(rt, rt);
    }

    int stk[N]; // 栈
    bool isl[N];
    std::vector<int> vg[N]; // 虚树
    std::vector<int> lst;   // 当前虚树中的点
    void buildvt(std::vector<int> pt, int rt = 0) {
        for (auto x: lst) vg[x].clear(), isl[x] = 0;
        lst.clear();
        std::sort(pt.begin(), pt.end(), [](int u, int v) {return idx[u] < idx[v];});

        int tp = 0;
        stk[++tp] = rt; lst.push_back(rt);
        for (auto u: pt) {
            if (u != rt) {
                int ll = lca(u, stk[tp]);
                if (ll != stk[tp]) {
                    while (idx[ll] < idx[stk[tp-1]]) 
                        vg[stk[tp-1]].push_back(stk[tp]), --tp;
                    vg[ll].push_back(stk[tp]);
                    if (idx[ll] > idx[stk[tp-1]]) stk[tp] = ll, lst.push_back(ll);
                    else --tp;
                }
                stk[++tp] = u, lst.push_back(u);
            }
            isl[u] = 1;
        }
        while (tp > 1) {
            vg[stk[tp-1]].push_back(stk[tp]);
            --tp;
        }
    }

    void add(int u, int v, int w = 0) {
        g[u].emplace_back(v, w);
        g[v].emplace_back(u, w);
    }
}


```


