# 图论

## LCA

+ 倍增

```cpp
void dfs(int u, int fa) {
    pa[u][0] = fa; dep[u] = dep[fa] + 1;
    for (int i = 1; i < SP; ++i) pa[u][i] = pa[pa[u][i - 1]][i - 1];
    for (int& v: G[u]) {
        if (v == fa) continue;
        dfs(v, u);
    }
}

int lca(int u, int v) {
    if (dep[u] < dep[v]) swap(u, v);
    int t = dep[u] - dep[v];
    for (int i = 0; i < SP; ++i) if (t & (1 << i)) u = pa[u][i];
    for (int i = SP-1; i >= 0; --i) {
        int uu = pa[u][i], vv = pa[v][i];
        if (uu != vv) { u = uu; v = vv; }
    }
    return u == v ? u : pa[u][0];
}
```

+ 树链剖分

```cpp
namespace HLD{
    const int N = 1e5+3;
    std::vector<std::pair<int, int> > g[N]; // 原本的树
    int idx[N]; // idx[x] -> 点x的dfs序号
    int ridx[N];// ridx[id] -> dfs序为id的点号
    int dep[N]; // dep[x] -> 点x的深度
    int siz[N]; // siz[x] -> 以点x为根的树的大小
    int top[N]; // top[x] -> 点x所在重链的顶点
    int fa[N];  // fa[x] -> 点x的父亲结点
    int son[N]; // son[x] -> 点x的重儿子
    int clk = 0;// clk -> dfs序号

    void init() {
        for (int i = 0; i <= clk; ++i)
            g[i].clear();
        clk = 0;
    }
    int lca(int u, int v) {
        while (top[u] != top[v]) {
            if (dep[top[u]] < dep[top[v]]) std::swap(u, v);
            u = fa[top[u]];
        }
        if (dep[u] > dep[v]) std::swap(u, v);
        return u;
    }
    void HLDinit(int rt) {
        std::function<void(int, int)> predfs1 = [&](int u, int f) {
            siz[u] = 1;
            int &maxs = son[u] = -1;
            for (auto &[to, w]: g[u]) {
                if (to == f) continue;
                fa[to] = u, dep[to] = dep[u] + 1;
                predfs1(to, u);
                siz[u] += siz[to];
                if (maxs == -1 || siz[to] > siz[maxs]) maxs = to;
            }
        };
        std::function<void(int, int)> predfs2 = [&](int u, int tp) {
            top[u] = tp;
            idx[u] = ++clk, ridx[clk] = u;
            if (son[u] != -1) {
                predfs2(son[u], tp);
            }
            for (auto &[to, w]: g[u]) {
                if (to != fa[u] && to != son[u]) predfs2(to, to);
            }
        };
        predfs1(rt, -1);
        predfs2(rt, rt);
    }
    
    void add(int u, int v, int w = 0) {
        g[u].emplace_back(v, w);
        g[v].emplace_back(u, w);
    }
}

```

## 连通性

### tarjan

```cpp
const int N = 1e5 + 3;
std::vector<int> g[N];
int dfn[N], dfnx = 0; // dfs序
int low[N]; // 最高点
int col[N], colx = 0; // 连通块标号
int stk[N], stktp = 0; // 当前链
bool instk[N];
void tarjan(int u, int f) {
    dfn[u] = low[u] = ++dfnx;
    stk[++stktp] = u;
    for (auto to: g[u]) {
        // if (to == f) continue;
        if (dfn[to]) {if (instk[to]) low[u] = std::min(dfn[to], low[u]);}
        else tarjan(to, u), low[u] = std::min(low[u], low[to]);
    }
    if (low[u] == dfn[u]) {
        ++colx;
        while (stk[stktp] != u) instk[stk[stktp]] = 0, col[stk[stktp--]] = colx;
        instk[stk[stktp]] = 0, col[stk[stktp--]] = colx;
    }
}
```

## 树

### 虚树

> 用栈处理形式上与笛卡尔树类似, 按顺序后处理右链部分

```cpp
namespace VirtualTree{
    const int N = 3e5+3;
    std::vector<std::pair<int, int> > g[N]; // 原本的树
    int idx[N]; // idx[x] -> 点x的dfs序号
    int ridx[N];// ridx[id] -> dfs序为id的点号
    int dep[N]; // dep[x] -> 点x的深度
    int siz[N]; // siz[x] -> 以点x为根的树的大小
    int top[N]; // top[x] -> 点x所在重链的顶点
    int fa[N];  // fa[x] -> 点x的父亲结点
    int son[N]; // son[x] -> 点x的重儿子
    int clk = 0;// clk -> dfs序号

    void init() {
        for (int i = 0; i <= clk; ++i)
            g[i].clear();
        clk = 0;
    }
    int lca(int u, int v) {
        while (top[u] != top[v]) {
            if (dep[top[u]] < dep[top[v]]) std::swap(u, v);
            u = fa[top[u]];
        }
        if (dep[u] > dep[v]) std::swap(u, v);
        return u;
    }
    void HLDinit(int rt) {
        std::function<void(int, int)> predfs1 = [&](int u, int f) {
            siz[u] = 1;
            int &maxs = son[u] = -1;
            for (auto &[to, w]: g[u]) {
                if (to == f) continue;
                fa[to] = u, dep[to] = dep[u] + 1;
                predfs1(to, u);
                siz[u] += siz[to];
                if (maxs == -1 || siz[to] > siz[maxs]) maxs = to;
            }
        };
        std::function<void(int, int)> predfs2 = [&](int u, int tp) {
            top[u] = tp;
            idx[u] = ++clk, ridx[clk] = u;
            if (son[u] != -1) {
                predfs2(son[u], tp);
            }
            for (auto &[to, w]: g[u]) {
                if (to != fa[u] && to != son[u]) predfs2(to, to);
            }
        };
        predfs1(rt, -1);
        predfs2(rt, rt);
    }

    int stk[N]; // 栈
    bool isl[N];
    std::vector<int> vg[N]; // 虚树
    std::vector<int> lst;   // 当前虚树中的点
    void buildvt(std::vector<int> pt, int rt = 0) {
        for (auto x: lst) vg[x].clear(), isl[x] = 0;
        lst.clear();
        sort(pt.begin(), pt.end(), [](int u, int v) {return idx[u] < idx[v];});

        int tp = 0;
        stk[++tp] = rt; lst.push_back(rt);
        for (auto u: pt) {
            if (u != rt) {
                int ll = lca(u, stk[tp]);
                if (ll != stk[tp]) {
                    while (idx[ll] < idx[stk[tp-1]]) 
                        vg[stk[tp-1]].push_back(stk[tp]), --tp;
                    vg[ll].push_back(stk[tp]);
                    if (idx[ll] > idx[stk[tp-1]]) stk[tp] = ll, lst.push_back(ll);
                    else --tp;
                }
                stk[++tp] = u, lst.push_back(u);
            }
            isl[u] = 1;
        }
        while (tp > 1) {
            vg[stk[tp-1]].push_back(stk[tp]);
            --tp;
        }
    }

    void add(int u, int v, int w = 0) {
        g[u].emplace_back(v, w);
        g[v].emplace_back(u, w);
    }
}

```


## 网络流

### Dinic

```cpp
class Dinic{
    struct E{
        int to, cp;
        E(int t, int c): to(t), cp(c) {}
    };

    int n, m, s, t;
    std::vector<E> edges;
    std::vector<std::vector<int> > G;
    int *d, *cur;
    
    bool BFS() {
        memset(d, 0, sizeof(int) * (n));
        std::queue<int> Q;
        Q.push(s); d[s] = 1;
        while (!Q.empty()) {
            int x = Q.front(); Q.pop();
            for (auto &i: G[x]) {
                E &e = edges[i];
                if (!d[e.to] && e.cp > 0) {
                    d[e.to] = d[x] + 1;
                    Q.push(e.to);
                }
            }
        }
        return d[t];
    }

    int DFS(int u, int cp) {
        if (u == t || !cp) return cp;
        int tmp = cp, f;
        for (int& i = cur[u]; i < G[u].size(); ++i) {
            E& e = edges[G[u][i]];
            if (d[u] + 1 == d[e.to]) {
                f = DFS(e.to, std::min(cp, e.cp));
                e.cp -= f;
                edges[G[u][i] ^ 1].cp += f;
                cp -= f;
                if (!cp) break;
            }
        }
        return tmp - cp;
    }
    
public:
    Dinic(int nn): n(nn), G(nn), m(0) {d = new int[nn], cur = new int[nn];}
    ~Dinic() {delete[] d; delete[] cur;}

    void add(int u, int v, int cap) {
        edges.emplace_back(v, cap);
        edges.emplace_back(u, 0);
        G[u].push_back(m++);
        G[v].push_back(m++);
    }

    int go(int ss, int tt) {
        s = ss, t = tt;
        int flow = 0;
        while (BFS()) {
            memset(cur, 0, sizeof(int) * n);
            flow += DFS(s, INF);
        }
        return flow;
    }
};
```

上下界只需要在建图的时候把上下界之差的出入不平衡的调整一下

最大流 == 最小割
