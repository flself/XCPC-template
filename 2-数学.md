# 数学

## 数论

### 数论整数

```cpp
constexpr int P = 998244353;
// assume -P <= x < 2P
int norm(int x) {
    // x %= P;
    if (x < 0) { x += P; }
    if (x >= P) { x -= P; }
    return x;
}
template<typename E>
E power(E n, int k) {
    E ret = E(1);
    while (k) {
        if (k & 1) ret *= n;
        n *= n;
        k >>= 1;
    } return ret;
}
struct Z {
    int x;
    Z(int x = 0) : x(norm(x)) {}
    int val() const { return x; }
    Z operator-() const { return Z(norm(P - x)); }
    Z inv() const { assert(x != 0); return power(*this, P - 2); }
    Z &operator*=(const Z &rhs) { x = (long long)(x) * rhs.x % P; return *this; }
    Z &operator+=(const Z &rhs) { x = norm(x + rhs.x); return *this; }
    Z &operator-=(const Z &rhs) { x = norm(x - rhs.x); return *this; }
    Z &operator/=(const Z &rhs) { return *this *= rhs.inv(); }
    friend Z operator*(const Z &lhs, const Z &rhs) { Z res = lhs; res *= rhs; return res; }
    friend Z operator+(const Z &lhs, const Z &rhs) { Z res = lhs; res += rhs; return res; }
    friend Z operator-(const Z &lhs, const Z &rhs) { Z res = lhs; res -= rhs; return res; }
    friend Z operator/(const Z &lhs, const Z &rhs) { Z res = lhs; res /= rhs; return res; }
    friend std::istream &operator>>(std::istream &is, Z &a) { long long v; is >> v; a = Z(v); return is; }
    friend std::ostream &operator<<(std::ostream &os, const Z &a) { return os << a.val(); }
};
Z operator"" _z(unsigned long long x) { return Z(x); }
```

### 拉格朗日差值法

```cpp
template<typename T>
T lintp(const vector<int>& x, const vector<T>& y, int k) {
    T ans = 0;
    for (int i = 0; i < x.size(); ++i) {
        if (k == x[i])
            return y[i];
        T u = 1, v = 1;
        for (int j = 0; j < x.size(); ++j) {
            if (i == j) continue;
            u *= (k - x[j]);
            v *= (x[i] - x[j]);
        }
        ans += y[i] * u / v;
    }
    return ans;
}
```

### 欧几里得

+ 扩展欧几里得

```cpp
int exgcd(int a, int b, int& x, int& y) {
    if (a == 0) {
        x = 0, y = 1;
        return b;
    }
    int ret = exgcd(b % a, a, x, y), xx = x;
    x = y - b / a * x;
    y = xx; 
    return ret;
}
```

#### 类欧几里得

+ $m = \lfloor \frac{an+b}{c} \rfloor$ .
+ $f(a,b,c,n)=\sum_{i=0}^n\lfloor\frac{ai+b}{c}\rfloor$ : 当 $a \ge c$ or $b \ge c$ 时, $f(a,b,c,n)=(\frac{a}{c})n(n+1)/2+(\frac{b}{c})(n+1)+f(a \bmod c,b \bmod c,c,n)$ ; 否则 $f(a,b,c,n)=nm-f(c,c-b-1,a,m-1)$ 。
+ $g(a,b,c,n)=\sum_{i=0}^n i \lfloor\frac{ai+b}{c}\rfloor$ : 当 $a \ge c$ or $b \ge c$ 时, $g(a,b,c,n)=(\frac{a}{c})n(n+1)(2n+1)/6+(\frac{b}{c})n(n+1)/2+g(a \bmod c,b \bmod c,c,n)$ ; 否则 $g(a,b,c,n)=\frac{1}{2} (n(n+1)m-f(c,c-b-1,a,m-1)-h(c,c-b-1,a,m-1))$ 。
+ $h(a,b,c,n)=\sum_{i=0}^n\lfloor \frac{ai+b}{c} \rfloor^2$ : 当 $a \ge c$ or $b \ge c$ 时, $h(a,b,c,n)=(\frac{a}{c})^2 n(n+1)(2n+1)/6 +(\frac{b}{c})^2 (n+1)+(\frac{a}{c})(\frac{b}{c})n(n+1)+h(a \bmod c, b \bmod c,c,n)+2(\frac{a}{c})g(a \bmod c,b \bmod c,c,n)+2(\frac{b}{c})f(a \bmod c,b \bmod c,c,n)$ ; 否则 $h(a,b,c,n)=nm(m+1)-2g(c,c-b-1,a,m-1)-2f(c,c-b-1,a,m-1)-f(a,b,c,n)$ 。


```cpp
template<typename T>
T lintp(const vector<int>& x, const vector<T>& y, int k) {
    T ans = 0;
    for (int i = 0; i < x.size(); ++i) {
        if (k == x[i])
            return y[i];
        T u = 1, v = 1;
        for (int j = 0; j < x.size(); ++j) {
            if (i == j) continue;
            u *= (k - x[j]);
            v *= (x[i] - x[j]);
        }
        ans += y[i] * u / v;
    }
    return ans;
}
```

### Miller-Rabin和Pollard-Rho


+ Miller-Rabin

```cpp
long long pow_128(__int128_t n, long long k, long long mo) {
    __int128_t ret = 1;
    while (k) {
        if (k & 1) (ret *= n) %= mo;
        (n *= n) %= mo;
        k >>= 1;
    } return ret;
}

bool miller_rabin(long long n) {
    static const long long jp[] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 };

    if (n <= 1 || (n > 2 && !(n & 1))) return false;
    for (long long p : jp) if (n % p == 0) return n == p;

    long long r = n - 1, x, y;
    long long e = 0;
    while (~r & 1) r >>= 1, ++e;
    for (long long p : jp) {
        x = pow_128(p, r, n);
        for (long long t = 0; t < e && x > 1; ++t) {
            y = (__int128_t)x * x % n;
            if (y == 1 && x != n - 1) return false;
            x = y;
        }
        if (x != 1) return false;
    }
    return true;
}

```

+ Pollar-rho

```cpp
std::mt19937 RD(time(0));
long long pollard_rho(long long x) {
    long long s = 0, t = 0;
    long long c = (long long)RD() % (x - 1) + 1;
    int step = 0, goal = 1;
    long long val = 1;
    for (goal = 1;; goal *= 2, s = t, val = 1) { // 倍增优化
        for (step = 1; step <= goal; ++step) {
            t = ((__int128_t)t * t + c) % x;
            val = (__int128_t)val * abs(t - s) % x;
            if ((step % 127) == 0) {
                long long d = std::__gcd(val, x);
                if (d > 1)
                    return d;
            }
        }
        long long d = std::__gcd(val, x);
        if (d > 1)
            return d;
    }
}

```


### 中国剩余定理

当 $r[i]$ 两两互质时，$x = a[i] (mod r[i])$ 的解为...
当 $r[i]$ 不两两互质时，比如 $x = m_1 p + a_1 = m_2 p + a_2$。由裴蜀定理，当 $a_2 - a_1$ 不能被 $gcd(m_{1}, m_{2})$ 整除时，无解；否则可以算出一组 $p$ 、 $q$ 满足条件，则原来的解就变成了 $x \equiv m_{1} p + a_{1} \mod lcm(m_{1}, m_{2})$ 。

> 有一种思路，当给的模数不是质数的时候，有可能可以将其分解成若干个质数相乘，再用CRT合并答案。

```cpp
/// @brief 中国剩余定理，求解 x = a[i] (mod r[i]) 的解。需要保证 r[i] 两两互质，否则需要先预处理。
/// @param a 方程组 x = a[i] (mod r[i]) 中的 a[i]
/// @param r 方程组 x = a[i] (mod r[i]) 中的 r[i]
/// @return 方程组 x = a[i] (mod r[i]) 的解
int CRT(std::vector<int> a, std::vector<int> r) {
    long long n = 1, ans = 0, k = a.size();
    for (int i = 0; i < k; ++i) n = n * r[i];
    for (int i = 0; i < k; ++i) {
        long long m = n / r[i], b, y;
        exgcd(m, r[i], b, y);
        ans = (ans + a[i] * m % n * b % n + n) % n;
    }
    return ans;
}

```

### 各种筛

| 筛法 | 场景 | 效率 |
| --- | --- | --- |
| Min-25筛 | $f(p)$ 是一个关于 $p$ 的多项式, $f(p^c)$ 能快速求 | $O(\frac{n^{\frac{3}{4}}} {\log n})$ |
| PN筛 | 找一个好求前缀和的积性函数 $g()$ 在 $p$ 处 $f(p) = g(p)$ | $O(\sqrt{n})$ |
| 杜教筛 | 找一个 $g()$ 使得 $f*g()$ 好求前缀和 | $O(n^{\frac{2}{3}})$ |

#### Min-25筛

$$
\begin{aligned}
    F_{k}(n)
    &= \sum_{i = 2}^{n} [p_{k} \le \operatorname{lpf}(i)] f(i) \\
    &= \sum_{\substack{k \le i \\ p_{i}^{2} \le n}} \sum_{\substack{c \ge 1 \\ p_{i}^{c} \le n}} f\left(p_{i}^{c}\right) ([c > 1] + F_{i + 1}\left(n / p_{i}^{c}\right)) + \sum_{\substack{k \le i \\ p_{i} \le n}} f(p_{i}) \\
    &= \sum_{\substack{k \le i \\ p_{i}^{2} \le n}} \sum_{\substack{c \ge 1 \\ p_{i}^{c} \le n}} f\left(p_{i}^{c}\right) ([c > 1] + F_{i + 1}\left(n / p_{i}^{c}\right)) + F_{\mathrm{prime}}(n) - F_{\mathrm{prime}}(p_{k - 1}) \\
    &= \sum_{\substack{k \le i \\ p_{i}^{2} \le n}} \sum_{\substack{c \ge 1 \\ p_{i}^{c + 1} \le n}} \left(f\left(p_{i}^{c}\right) F_{i + 1}\left(n / p_{i}^{c}\right) + f\left(p_{i}^{c + 1}\right)\right) + F_{\mathrm{prime}}(n) - F_{\mathrm{prime}}(p_{k - 1})
\end{aligned}
$$
$$
G_{k}(n) = G_{k - 1}(n) - \left[p_{k}^{2} \le n\right] g(p_{k}) (G_{k - 1}(n / p_{k}) - G_{k - 1}(p_{k - 1}))
$$

```cpp
namespace Min_25{
    bool INI = 0;
    int M = 0, sqn = 0;
    std::vector<int> primes;
    Z (*fp)(int, int);  // f(p^c)
    Z fp_single(int p, int c) {
        return power(Z(p), c);
    }
    Z sgp(int n, int c) {
        if (c == 0) return Z(n);
        if (c == 1) return Z(n+ 1) * n / 2;
        if (c == 2) return Z(2*n+1) * (n+1) * n / 6;
        // if (c == 3) return Z(n) * n * (n+1) * (n+1) / 4;
        // if (c == 4) return Z(n) * (n+1) * (2*n+1) * (3*n*n%P + 3*n - 1) / 30;
    }
    struct Gpoly{
        int M, sqn, a;
        std::vector<Z> F_prime1, F_prime2;
        Gpoly(int scale, int a, int c): M(scale), a(a) {
            sqn = sqrt(M) + 3; 
            F_prime1.resize(sqn), F_prime2.resize(sqn);

            int st = M, ed = 1;
            for (int i = 1; st >= ed; st = min(M / ++i, st - 1)) {
                (*this)[st] = sgp(st, c) - 1;
            }
            for (int j = 1; j < primes.size(); ++j) {
                st = M, ed = primes[j] * primes[j];
                Z pc = fp_single(primes[j], c);
                for (int i = 1; st >= ed; st = min(M / ++i, st - 1)) {
                    (*this)[st] -= pc * ((*this)[st/primes[j]] - (*this)[primes[j-1]]);
                }
            }
        }
        void seta(int aa) {a = aa;}
        Z & operator [](int idx) {
            if (idx < sqn) return F_prime1[idx];
            return F_prime2[M/idx];
        }
    };

    std::vector<Gpoly> Gp;
    Z G(int x){
        Z res = 0;
        for (auto &g: Gp) res += g[x] * g.a;
        return res;
    }
    void init(int scale) {
        if (M < scale) INI = 0;
        M = scale, sqn = sqrt(M) + 5;
        
        if (!INI) {
            INI = 1;
            std::vector<signed> vis(sqn);
            primes.resize(1, 1);
            for (int i = 2; i < sqn; ++i) {
                if (!vis[i]) primes.push_back(i);
                for (int j = 1; j < primes.size(); ++j) {
                    auto prm = primes[j];
                    if (prm * i >= sqn) break;
                    vis[i * prm] = 1;
                    if (i % prm == 0) break; 
                }
            }

        }

        Gp.clear();
        // Gp.emplace_back(scale, a, c); // a*p^c
    }
    Z seive(int n, int k) {
        Z res = G(n) - G(primes[k-1]);
        for (int i = k; i < primes.size() && primes[i] * primes[i] <= n; ++i) {
            Z fpj = fp(primes[i], 1), fpj1;
            for (int j = 1, pc = primes[i]; pc * primes[i] <= n; ++j, pc *= primes[i], fpj = fpj1) {
                fpj1 = fp(primes[i], j + 1);
                res += fpj * seive(n/pc, i + 1) + fpj1;
            }
        }
        return res;
    }
    Z S_f(int n) {
        return seive(n, 1) + 1;
    }
    void seta(const std::vector<int>& a) {for (int i = 0; i < Gp.size() && i < a.size(); ++i) Gp[i].seta(a[i]);}
}


```

#### PN筛(Powerful Number)

```cpp

// f = (g*h); f(p) = g(p) + h(p) [with f(p) = g(p)] -> h[p] = 0.
namespace PowerfulNumber{
    bool INI = 0;
    std::vector<int> primes;
    std::vector<std::vector<Z> > h;
    int M;
    Z (*fp)(int, int);  // f(p^c)
    Z (*gp)(int, int);  // g(p^c)
    Z (*S_g)(int);      // preffix sum of g()

    // if lack of a formula of h(i, j), you need to set f() and g() beforehand
    void init(int scale) {
        if (M < scale) INI = 0;
        M = scale;
        int n = std::sqrt(M)+10;
        if (!INI) {
            INI = 1;
            primes.resize(0);
            std::vector<signed> vis(n);
            for (int i = 2; i < n; ++i) {
                if (!vis[i]) primes.push_back(i);
                for (auto prm: primes) {
                    if (prm * i >= n) break;
                    vis[i * prm] = 1;
                    if (i % prm == 0) break; 
                }
            }
            h.resize(primes.size(), std::vector<Z>((int)(log2(M))+1));
        }

        // get the function h() (with f() and g() set or with formula of h())
        for (int i = 0; i < h.size(); ++i) {
            int pp = primes[i] * primes[i];
            if (pp > M) break;
            h[i][0] = 1;
            for (int j = 2; pp <= M && j < h[i].size(); ++j, pp *= primes[i]) {
                Z sgh = 0;
                for (int k = 1, xp = primes[i]; k <= j; ++k, xp *= primes[i]) {
                    sgh += gp(primes[i], xp) * h[i][j-k];
                }
                h[i][j] = fp(pp, j) - sgh;
                // h[i][j] = Z(j-1) * (pp * primes[i] % P - pp % P);
                // h[i][j] = Z(-pp) / (j * (j-1));
                // [a formula of h(i, j)], better faster than log, this example can be optimized to O(1).
            }
        }
    }

    // assistance func to get the sum
    Z PN_sieve(int n, int flr, Z hd) {
        Z res = S_g(n)*hd;
        for(int i = flr+1; i < primes.size(); ++i) {
            int prm=primes[i], k=1;
            int val=n/prm, pk=prm;

            if(val < prm) break;
            while(val >= prm) {
                val /= prm;
                pk *= prm;
                ++k;
                
                res += PN_sieve(val, i, hd*h[i][k]);
            }
        }
        return res;
    }
    // func to get the sum
    Z getsumf(int n) {
        return PN_sieve(n, -1, 1);
    }
}

```

#### 杜教筛

```cpp
// g(1)S(n) = \sum_{i=1}^{n}(f*g)(i) - \sum_{i=2}^{n}g(i)S(n/i)
namespace dujiaoshai{
    std::vector<Z> smallS;
    map<int, Z> bigS;

    void Set_smallS(int);
    Z (*S_fg)(int);
    Z (*S_g)(int);
    Z getS(int n) {
        if (n < smallS.size())  return smallS[n];
        else if (bigS.count(n)) return bigS[n];
        Z res = S_fg(n);
        for (int l = 2, r; l <= n; l = r + 1) {
            r = n / (n / l);
            res -= (S_g(r) - S_g(l-1)) * getS(n/l);
        }
        // res /= S_g(1);
        return (bigS[n] = res);
    }
}

void dujiaoshai::Set_smallS(int siz) {
    int n = pow(siz, 0.67);
    smallS.assign(n, 0);
    smallS[1] = 1;
    std::vector<signed> vis(n), primes;
    for (int i = 2; i < n; ++i) {
        if (!vis[i]) {
            primes.push_back(i);
            smallS[i] = i - 1;
        }
        for (auto &prm: primes) {
            if (i * prm >= n) break;
            vis[i * prm] = 1;
            if (i % prm == 0) {
                smallS[i * prm] = smallS[i] * prm;
                break;
            }
            smallS[i * prm] = smallS[i] * (prm - 1);
        }
        smallS[i] = smallS[i-1] + smallS[i]*i;
    }
}
```

### 多项式

+ Poly with NTT

```cpp

std::vector<int> rev;
std::vector<Z> roots{0, 1};
void dft(std::vector<Z> &a) {
    int n = a.size();
    
    if ((int)(rev.size()) != n) {
        int k = __builtin_ctz(n) - 1;
        rev.resize(n);
        for (int i = 0; i < n; i++) {
            rev[i] = rev[i >> 1] >> 1 | (i & 1) << k;
        }
    }
    
    for (int i = 0; i < n; i++) {
        if (rev[i] < i) {
            std::swap(a[i], a[rev[i]]);
        }
    }
    if ((int)(roots.size()) < n) {
        int k = __builtin_ctz(roots.size());
        roots.resize(n);
        while ((1 << k) < n) {
            Z e = power(Z(3), (P - 1) >> (k + 1));
            for (int i = 1 << (k - 1); i < (1 << k); i++) {
                roots[2 * i] = roots[i];
                roots[2 * i + 1] = roots[i] * e;
            }
            k++;
        }
    }
    for (int k = 1; k < n; k *= 2) {
        for (int i = 0; i < n; i += 2 * k) {
            for (int j = 0; j < k; j++) {
                Z u = a[i + j];
                Z v = a[i + j + k] * roots[k + j];
                a[i + j] = u + v;
                a[i + j + k] = u - v;
            }
        }
    }
}
void idft(std::vector<Z> &a) {
    int n = a.size();
    std::reverse(a.begin() + 1, a.end());
    dft(a);
    Z inv = (1 - P) / n;
    for (int i = 0; i < n; i++) {
        a[i] *= inv;
    }
}
struct Poly {
    std::vector<Z> a;
    Poly() {}
    Poly(const std::vector<Z> &a) : a(a) {}
    Poly(const std::initializer_list<Z> &a) : a(a) {}
    int size() const {
        return a.size();
    }
    void resize(int n) {
        a.resize(n);
    }
    Z operator[](int idx) const {
        if (idx < size()) {
            return a[idx];
        } else {
            return 0;
        }
    }
    Z &operator[](int idx) {
        return a[idx];
    }
    Poly mulxk(int k) const {
        auto b = a;
        b.insert(b.begin(), k, 0);
        return Poly(b);
    }
    Poly modxk(int k) const {
        k = std::min(k, size());
        return Poly(std::vector<Z>(a.begin(), a.begin() + k));
    }
    Poly divxk(int k) const {
        if (size() <= k) {
            return Poly();
        }
        return Poly(std::vector<Z>(a.begin() + k, a.end()));
    }
    friend Poly operator+(const Poly &a, const Poly &b) {
        std::vector<Z> res(std::max(a.size(), b.size()));
        for (int i = 0; i < (int)(res.size()); i++) {
            res[i] = a[i] + b[i];
        }
        return Poly(res);
    }
    friend Poly operator-(const Poly &a, const Poly &b) {
        std::vector<Z> res(std::max(a.size(), b.size()));
        for (int i = 0; i < (int)(res.size()); i++) {
            res[i] = a[i] - b[i];
        }
        return Poly(res);
    }
    friend Poly operator*(Poly a, Poly b) {
        if (a.size() == 0 || b.size() == 0) {
            return Poly();
        }
        int sz = 1, tot = a.size() + b.size() - 1;
        while (sz < tot) {
            sz *= 2;
        }
        a.a.resize(sz);
        b.a.resize(sz);
        dft(a.a);
        dft(b.a);
        for (int i = 0; i < sz; ++i) {
            a.a[i] = a[i] * b[i];
        }
        idft(a.a);
        a.resize(tot);
        return a;
    }
    friend Poly operator*(Z a, Poly b) {
        for (int i = 0; i < (int)(b.size()); i++) {
            b[i] *= a;
        }
        return b;
    }
    friend Poly operator*(Poly a, Z b) {
        for (int i = 0; i < (int)(a.size()); i++) {
            a[i] *= b;
        }
        return a;
    }
    Poly &operator+=(Poly b) {
        return (*this) = (*this) + b;
    }
    Poly &operator-=(Poly b) {
        return (*this) = (*this) - b;
    }
    Poly &operator*=(Poly b) {
        return (*this) = (*this) * b;
    }
    Poly deriv() const {
        if (a.empty()) {
            return Poly();
        }
        std::vector<Z> res(size() - 1);
        for (int i = 0; i < size() - 1; ++i) {
            res[i] = (i + 1) * a[i + 1];
        }
        return Poly(res);
    }
    Poly integr() const {
        std::vector<Z> res(size() + 1);
        for (int i = 0; i < size(); ++i) {
            res[i + 1] = a[i] / (i + 1);
        }
        return Poly(res);
    }
    Poly inv(int m) const {
        Poly x{a[0].inv()};
        int k = 1;
        while (k < m) {
            k *= 2;
            x = (x * (Poly{2} - modxk(k) * x)).modxk(k);
        }
        return x.modxk(m);
    }
    Poly log(int m) const {
        return (deriv() * inv(m)).integr().modxk(m);
    }
    Poly exp(int m) const {
        Poly x{1};
        int k = 1;
        while (k < m) {
            k *= 2;
            x = (x * (Poly{1} - x.log(k) + modxk(k))).modxk(k);
        }
        return x.modxk(m);
    }
    Poly pow(int k, int m) const {
        int i = 0;
        while (i < size() && a[i].val() == 0) {
            i++;
        }
        if (i == size() || 1LL * i * k >= m) {
            return Poly(std::vector<Z>(m));
        }
        Z v = a[i];
        auto f = divxk(i) * v.inv();
        return (f.log(m - i * k) * k).exp(m - i * k).mulxk(i * k) * power(v, k);
    }
    Poly sqrt(int m) const {
        Poly x{1};
        int k = 1;
        while (k < m) {
            k *= 2;
            x = (x + (modxk(k) * x.inv(k)).modxk(k)) * ((P + 1) / 2);
        }
        return x.modxk(m);
    }
    Poly mulT(Poly b) const {
        if (b.size() == 0) {
            return Poly();
        }
        int n = b.size();
        std::reverse(b.a.begin(), b.a.end());
        return ((*this) * b).divxk(n - 1);
    }
    std::vector<Z> eval(std::vector<Z> x) const {
        if (size() == 0) {
            return std::vector<Z>(x.size(), 0);
        }
        const int n = std::max((int)(x.size()), size());
        std::vector<Poly> q(4 * n);
        std::vector<Z> ans(x.size());
        x.resize(n);
        std::function<void(int, int, int)> build = [&](int p, int l, int r) {
            if (r - l == 1) {
                q[p] = Poly{1, -x[l]};
            } else {
                int m = (l + r) / 2;
                build(2 * p, l, m);
                build(2 * p + 1, m, r);
                q[p] = q[2 * p] * q[2 * p + 1];
            }
        };
        build(1, 0, n);
        std::function<void(int, int, int, const Poly &)> work = [&](int p, int l, int r, const Poly &num) {
            if (r - l == 1) {
                if (l < (int)(ans.size())) {
                    ans[l] = num[0];
                }
            } else {
                int m = (l + r) / 2;
                work(2 * p, l, m, num.mulT(q[2 * p + 1]).modxk(m - l));
                work(2 * p + 1, m, r, num.mulT(q[2 * p]).modxk(r - m));
            }
        };
        work(1, 0, n, mulT(q[1].inv(n)));
        return ans;
    }
};

```

+ FFT

```cpp
namespace FFT { // n_是初始的数组长度, 不一定为2的幂次; n是init之后的长度, 保证为2的幂次长度
    const double PI = acos(-1);
    int rev[1 << 20];
    int init(int n_) {
        int step = 0, n = 1;
        for (; n < n_; n <<= 1) ++step;
        for (int i = 1; i < n; ++i) {
            rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (step - 1));
        }
        return n;
    }
    void FFT(complex<double> a[], int n, int f) {
        for (int i = 0; i < n; ++i) {
            if (i < rev[i]) std::swap(a[i], a[rev[i]]);
        }
        for (int h = 2; h <= n; h <<= 1) {
            complex<double> wn(cos(f * 2 * PI / h), sin(f * 2 * PI / h));
            for (int i = 0; i < n; i += h) {
                complex<double> w(1, 0), u;
                for (int j = i, k = h >> 1; j < i + k; ++j) {
                    u = a[j + k] * w;
                    a[j + k] = a[j] - u;
                    a[j] = a[j] + u;
                    w = w * wn;
                }
            }
        }
        if (f == -1) {
            for (int i = 0; i < n; ++i) {
                a[i] = {a[i].real() / n, 0};
            }
        }
    }
    void conv(complex<double> a[], complex<double> b[], int n_) { // n_ does not represent the pow of 2.
        int n = init(n_);
        FFT(a, n, 1);
        FFT(b, n, 1);
        for (int i = 0; i < n; ++i) a[i] *= b[i];
        FFT(a, n, -1);
    }
}
```

## 组合数学

### 卡特兰数

可以将问题划分为两个子问题的问题, 满足递推式:
$$
H_n = \begin{cases}
    \sum_{i=1}^{n} H_{i-1} H_{n-i} & n \geq 2, n \in \mathbf{N_{+}}\\
    1 & n = 0, 1
\end{cases}
$$

递推式: $H_n = \dfrac{H_{n-1}(4n-2)}{n+1}$
通项式: $H_n = \binom{2n}{n} - \binom{2n}{n-1}$

### 斯特林数

将 $n$ 个不相同的元素划分为 $k$ 个互不区分的集合, $\begin{Bmatrix} n \\ k \end{Bmatrix}$ , 也记作 $S(n, k)$ .

递推式: $S(n,k) = S(n-1,k) + k\times S(n-1, k)$
通项公式: $\begin{Bmatrix} n \\ m \end{Bmatrix} = \sum \limits_{i=0} ^m \dfrac{(-1)^{m-i} i^n}{i! (m-i)!}$

#### 第二类斯特林数

```cpp
struct Stirling2 {
    std::vector<std::vector<Z> > S;
    Stirling2 (int n) {
        S.resize(n+1, vector<Z>(n+1));
        S[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= n; ++j) {
                S[i][j] = S[i-1][j-1] + S[i-1][j] * j;
            }
        }
    }
    std::vector<Z> &operator [](int idx) {return S[idx];}
};


struct Stirling2_oneline {
    std::vector<Z> S;
    int n;
    // S[n][k] = \sum \frac {i^n (-1)^{m-i}}{i! (m-i)!}
    // that is convolution of f(x) = x^n / (x!) and g(x) = (-1)^x / (x!)
    Stirling2_oneline(int _n): n(_n) {
        vector<Z> f(n+1), g(n+1), ifact(n+1);
        g[0] = 1;

        Z fact = 1;
        for (int i = 1; i <= n; ++i) fact *= i;
        ifact[n] = fact.inv();
        for (int i = n-1; i >= 1; --i) {
            ifact[i] = ifact[i+1] * (i+1);
        }

        for (int i = 1; i <= n; ++i) {
            f[i] = power(Z(i), n) * ifact[i];
            g[i] = ifact[i] * (i % 2? -1: 1);
        }

        S = (Poly(f) * Poly(g)).modxk(n+1).a;
    }
    Z operator [](int idx) {return S[idx];}
};

```

### 分拆数

将 $n$ 分成 $k$ 个部分的分拆, 称为 $k$ 部分拆, 记作 $p(n,k)$

递推式: $p(n,k) = p(n-1, k-1) + p(n-k, k)$

### 容斥原理

![集合](assets\incexcp.png)
$|A\cup B\cup C|=|A|+|B|+|C|-|A\cap B|-|B\cap C|-|C\cap A|+|A\cap B\cap C|$

进一步推广:

$$
\begin{split}
\left|\bigcup_{i=1}^{n}S_i\right|=&\sum_{i}|S_i|-\sum_{i<j}|S_i\cap S_j|+\sum_{i<j<k}|S_i\cap S_j\cap S_k|-\cdots\\
&+(-1)^{m-1}\sum_{a_i<a_{i+1} }\left|\bigcap_{i=1}^{m}S_{a_i}\right|+\cdots+(-1)^{n-1}|S_1\cap\cdots\cap S_n|
\end{split}
$$

经典例子: 不定方程非负整数解

## 线性代数

### 矩阵

```cpp
template<typename E>
struct Matrix{
    std::vector<std::vector<E> > a;
    Matrix(int _n): a(_n, std::vector<E> (_n)) {}
    Matrix(int _n, int _m): a(_n, std::vector<E>(_m)) {}
    Matrix(int _n, const std::vector<E>& vec): a(_n, std::vector<E>(_n)) {
        for (int _i = 0; _i < _n; ++_i) {
            a[_i].assign(vec.begin() + _i * _n, vec.begin() + (_i + 1) * _n);
        }
    }
    Matrix(int _n, const std::initializer_list<E>& vec): a(_n, std::vector<E>(_n)) {
        for (int _i = 0; _i < _n; ++_i) {
            a[_i].assign(vec.begin() + _i * _n, vec.begin() + (_i + 1) * _n);
        }
    }
    Matrix(int _n, int _m, const std::vector<E>& vec): a(_n, std::vector<E>(_m)) {
        for (int _i = 0; _i < _n; ++_i) {
            a[_i].assign(vec.begin() + _i * _m, vec.begin() + (_i + 1) * _m);
        }
    }
    Matrix(int _n, int _m, const std::initializer_list<E>& vec): a(_n, std::vector<E>(_m)) {
        for (int _i = 0; _i < _n; ++_i) {
            a[_i].assign(vec.begin() + _i * _m, vec.begin() + (_i + 1) * _m);
        }
    }
    Matrix(const Matrix<E>& B) {
        a.resize(B.a.size());
        for (int _i = 0; _i < a.size(); ++_i) a[_i].assign(B.a[_i].begin(), B.a[_i].end());
    }

    ~Matrix() {}

    const std::vector<E>& operator [](int idx) const {return a[idx];}
    std::vector<E>& operator [](int idx) {return a[idx];}
    Matrix<E> operator =(E x) { // 如果不是方阵就全置0
        for (int _i = 0; _i < a.size(); ++_i) {
            a[_i].assign(a[_i].size(), E(0));
            if (a[_i].size() == a.size()) a[_i][_i] = x;
        }
        return (*this);
    }
    Matrix<E> operator =(const Matrix<E>& B) {
        a.resize(B.a.size());
        for (int _i = 0; _i < a.size(); ++_i) {
            a[_i].assign(B.a[_i].begin(), B.a[_i].end());
        }
        return (*this);
    }
    Matrix<E> operator +=(const Matrix<E>& B) {
        int _n = min(a.size(), B.a.size()), _m = min(a[0].size(), B.a[0].size());
        for (int _i = 0; _i < _n; ++_i) {
            for (int _j = 0; _j < _m; ++_j) {
                a[_i][_j] += B[_i][_j];
            }
        }
        return (*this);
    }
    Matrix<E> operator *=(const E& x) {
        for (int _i = 0; _i < a.size(); ++_i) {
            for (int _j = 0; _j < a[_i].size(); ++_j) {
                a[_i][_j] *= x;
            }
        }
        return (*this);
    }
    Matrix<E> operator *(const Matrix<E>& B) {
        if (a[0].size() != B.a.size()) return Matrix<E> (1);
        Matrix<E> ret(a.size(), B.a[0].size());

        int _n = a.size(), _m = B.a[0].size(), _z = a[0].size();
        for (int _i = 0; _i < _n; ++_i) {
            for (int _k = 0; _k < _z; ++_k) {
                E x = a[_i][_k];
                for (int _j = 0; _j < _m; ++_j) {
                    (ret[_i][_j] += x * B[_k][_j]);
                }
            }
        }
        return ret;
    }
    Matrix<E> operator *=(const Matrix<E>& B) {
        Matrix<E> res((*this) * B);
        *this = res;
        return (*this);
    }
    Matrix<E> operator +(const Matrix<E>& B) {
        Matrix<E> ret(*this);
        return (ret += B);
    }
};
template<typename E>
Matrix<E> mpow(Matrix<E> n, int k) {
    Matrix<E> ret(n);
    ret = E(1);
    while (k) {
        if (k & 1) (ret *= n);
        (n *= n);
        k >>= 1; 
    } return ret;
}
```

### 线性基

```cpp
struct LinearBase{
    std::vector<int> LBP;
    LinearBase(): LBP(64) {}
    LinearBase(int _n): LBP(_n) {}

    void insert(int x) {
        for (int i = (int)LBP.size() - 1; i >= 0; --i) {
            if ((x >> i) & 1) {
                if (!LBP[i]) {LBP[i] = x; break;}
                else x ^= LBP[i];
            }
            else continue;
        }
    }
    bool query(int x) {
        for (int i = (int)LBP.size() - 1; i >= 0; --i) {
            if ((x >> i) & 1) x ^= LBP[i];
        }
        return (x == 0);
    }
    int MaxSum() {
        int ret = 0;
        for (int i = (int)LBP.size() - 1; i >= 0; --i) {
            if ((ret >> i) & 1) continue;
            else ret ^= LBP[i];
        }
        return ret;
    }
};
```

## 博弈论

Sprague-Grundy Theorem (SG定理), 将多个游戏的SG值异或起来就能表示组合起来的胜负状态. 可以归纳法来证明.


## 微积分

### simpson积分


```cpp
const double EPS = 1e-9;
double f(double x) {
    return x;
}

double simpson(double l, double r) {
    double mid = (l + r) / 2;
    return (r - l) * (f(l) + f(mid) * 4 + f(r)) / 6;
}

double adaptive(double l, double r, double ans, double eqs, int step) {
    double mid = (l + r) / 2;
    double fl = simpson(l, mid), fr = simpson(mid, r);
    if (fabs(fl + fr - ans) <= 15 * eqs || step < 0) return fl + fr + fabs(fl + fr - ans) / 15;
    return adaptive(l, mid, fl, eqs/2, step-1) + adaptive(mid, r, fr, eqs/2, step-1);
}

```

## Geometry

### jiangly版本

```cpp
template<class T>
struct Point {
    T x;
    T y;
    Point(T x_ = 0, T y_ = 0) : x(x_), y(y_) {}
     
    template<class U>
    operator Point<U>() { return Point<U>(U(x), U(y)); }
    Point &operator+=(Point p) & { x += p.x; y += p.y; return *this; }
    Point &operator-=(Point p) & { x -= p.x; y -= p.y; return *this; }
    Point &operator*=(T v) & { x *= v; y *= v; return *this; }
    Point &operator/=(T v) & { x /= v; y /= v; return *this; }
    Point operator-() const { return Point(-x, -y); }
    friend Point operator+(Point a, Point b) { return a += b; }
    friend Point operator-(Point a, Point b) { return a -= b; }
    friend Point operator*(Point a, T b) { return a *= b; }
    friend Point operator/(Point a, T b) { return a /= b; }
    friend Point operator*(T a, Point b) { return b *= a; }
    friend bool operator==(Point a, Point b) { return a.x == b.x && a.y == b.y; }
    friend std::istream &operator>>(std::istream &is, Point &p) { return is >> p.x >> p.y; }
    friend std::ostream &operator<<(std::ostream &os, Point p) { return os << "(" << p.x << ", " << p.y << ")"; }
};
 
template<class T>
T dot(Point<T> a, Point<T> b) { return a.x * b.x + a.y * b.y; }
 
template<class T>
T cross(Point<T> a, Point<T> b) { return a.x * b.y - a.y * b.x; }
 
template<class T>
T square(Point<T> p) { return dot(p, p); }
template<class T>
double length(Point<T> p) { return std::sqrt(double(square(p))); }
long double length(Point<long double> p) { return std::sqrt(square(p)); }
template<class T>
Point<T> normalize(Point<T> p) { return p / length(p); }
template<class T>
struct Line {
    Point<T> a;
    Point<T> b;
    Line(Point<T> a_ = Point<T>(), Point<T> b_ = Point<T>()) : a(a_), b(b_) {}
};
template<class T>
double nearest(Point<T> p, Line<T> l) {
    if (dot(l.b - l.a, p - l.a) < 0) return length(p - l.a);
    if (dot(l.a - l.b, p - l.b) < 0) return length(p - l.b);
    return std::abs(cross(l.b - l.a, p - l.a)) / length(l.b - l.a);
}
long double nearest(Point<long double> p, Line<long double> l) {
    if (dot(l.b - l.a, p - l.a) < 0) return length(p - l.a);
    if (dot(l.a - l.b, p - l.b) < 0) return length(p - l.b);
    return std::abs(cross(l.b - l.a, p - l.a)) / length(l.b - l.a);
}
template<class T>
Point<T> rotate(Point<T> a) { return Point(-a.y, a.x); }
template<class T>
int sgn(Point<T> a) { return a.y > 0 || (a.y == 0 && a.x > 0) ? 1 : -1; }
template<class T>
bool pointOnLineLeft(Point<T> p, Line<T> l) { return cross(l.b - l.a, p - l.a) > 0; }
 
template<class T>
Point<T> lineIntersection(Line<T> l1, Line<T> l2) { return l1.a + (l1.b - l1.a) * (cross(l2.b - l2.a, l1.a - l2.a) / cross(l2.b - l2.a, l1.a - l1.b)); }
template<class T>
bool pointOnSegment(Point<T> p, Line<T> l) {
    return cross(p - l.a, l.b - l.a) == 0 && std::min(l.a.x, l.b.x) <= p.x && p.x <= std::max(l.a.x, l.b.x)
        && std::min(l.a.y, l.b.y) <= p.y && p.y <= std::max(l.a.y, l.b.y);
}
template<class T>
bool pointInPolygon(Point<T> a, std::vector<Point<T>> p) {
    int n = p.size();
    for (int i = 0; i < n; i++) {
        if (pointOnSegment(a, Line(p[i], p[(i + 1) % n]))) {
            return true;
        }
    }
     
    int t = 0;
    for (int i = 0; i < n; i++) {
        auto u = p[i];
        auto v = p[(i + 1) % n];
        if (u.x < a.x && v.x >= a.x && pointOnLineLeft(a, Line(v, u))) {
            t ^= 1;
        }
        if (u.x >= a.x && v.x < a.x && pointOnLineLeft(a, Line(u, v))) {
            t ^= 1;
        }
    }
     
    return t == 1;
}
template<class T>
std::vector<Point<T>> convexHull(std::vector<Point<T>> p) {
    std::sort(p.begin(), p.end(), [](Point<T> a, Point<T> b) {
        return a.x < b.x || (a.x == b.x && a.y < b.y);
    });
    std::vector<Point<T>> res;
    for (int i = 0; i < p.size(); i++) {
        while (res.size() >= 2 && cross(res[res.size() - 1] - res[res.size() - 2], p[i] - res[res.size() - 2]) <= 0) {
            res.pop_back();
        }
        res.push_back(p[i]);
    }
    int t = res.size();
    for (int i = (int)p.size() - 2; i >= 0; i--) {
        while (res.size() > t && cross(res[res.size() - 1] - res[res.size() - 2], p[i] - res[res.size() - 2]) <= 0) {
            res.pop_back();
        }
        res.push_back(p[i]);
    }
    res.pop_back();
    return res;
}
 
// 0 : not intersect
// 1 : strictly intersect
// 2 : overlap
// 3 : intersect at endpoint
template<class T>
std::tuple<int, Point<T>, Point<T>> segmentIntersection(Line<T> l1, Line<T> l2) {
    if (std::max(l1.a.x, l1.b.x) < std::min(l2.a.x, l2.b.x)) {
        return {0, Point<T>(), Point<T>()};
    }
    if (std::min(l1.a.x, l1.b.x) > std::max(l2.a.x, l2.b.x)) {
        return {0, Point<T>(), Point<T>()};
    }
    if (std::max(l1.a.y, l1.b.y) < std::min(l2.a.y, l2.b.y)) {
        return {0, Point<T>(), Point<T>()};
    }
    if (std::min(l1.a.y, l1.b.y) > std::max(l2.a.y, l2.b.y)) {
        return {0, Point<T>(), Point<T>()};
    }
    if (cross(l1.b - l1.a, l2.b - l2.a) == 0) {
        if (cross(l1.b - l1.a, l2.a - l1.a) != 0) {
            return {0, Point<T>(), Point<T>()};
        } else {
            auto maxx1 = std::max(l1.a.x, l1.b.x);
            auto minx1 = std::min(l1.a.x, l1.b.x);
            auto maxy1 = std::max(l1.a.y, l1.b.y);
            auto miny1 = std::min(l1.a.y, l1.b.y);
            auto maxx2 = std::max(l2.a.x, l2.b.x);
            auto minx2 = std::min(l2.a.x, l2.b.x);
            auto maxy2 = std::max(l2.a.y, l2.b.y);
            auto miny2 = std::min(l2.a.y, l2.b.y);
            Point<T> p1(std::max(minx1, minx2), std::max(miny1, miny2));
            Point<T> p2(std::min(maxx1, maxx2), std::min(maxy1, maxy2));
            if (!pointOnSegment(p1, l1)) {
                std::swap(p1.y, p2.y);
            }
            if (p1 == p2) {
                return {3, p1, p2};
            } else {
                return {2, p1, p2};
            }
        }
    }
    auto cp1 = cross(l2.a - l1.a, l2.b - l1.a);
    auto cp2 = cross(l2.a - l1.b, l2.b - l1.b);
    auto cp3 = cross(l1.a - l2.a, l1.b - l2.a);
    auto cp4 = cross(l1.a - l2.b, l1.b - l2.b);
     
    if ((cp1 > 0 && cp2 > 0) || (cp1 < 0 && cp2 < 0) || (cp3 > 0 && cp4 > 0) || (cp3 < 0 && cp4 < 0)) {
        return {0, Point<T>(), Point<T>()};
    }
     
    Point p = lineIntersection(l1, l2);
    if (cp1 != 0 && cp2 != 0 && cp3 != 0 && cp4 != 0) {
        return {1, p, p};
    } else {
        return {3, p, p};
    }
}
 
template<class T>
bool segmentInPolygon(Line<T> l, std::vector<Point<T>> p) {
    int n = p.size();
    if (!pointInPolygon(l.a, p)) {
        return false;
    }
    if (!pointInPolygon(l.b, p)) {
        return false;
    }
    for (int i = 0; i < n; i++) {
        auto u = p[i];
        auto v = p[(i + 1) % n];
        auto w = p[(i + 2) % n];
        auto [t, p1, p2] = segmentIntersection(l, Line(u, v));
         
        if (t == 1) {
            return false;
        }
        if (t == 0) {
            continue;
        }
        if (t == 2) {
            if (pointOnSegment(v, l) && v != l.a && v != l.b) {
                if (cross(v - u, w - v) > 0) {
                    return false;
                }
            }
        } else {
            if (p1 != u && p1 != v) {
                if (pointOnLineLeft(l.a, Line(v, u))
                    || pointOnLineLeft(l.b, Line(v, u))) {
                    return false;
                }
            } else if (p1 == v) {
                if (l.a == v) {
                    if (pointOnLineLeft(u, l)) {
                        if (pointOnLineLeft(w, l)
                            && pointOnLineLeft(w, Line(u, v))) {
                            return false;
                        }
                    } else {
                        if (pointOnLineLeft(w, l)
                            || pointOnLineLeft(w, Line(u, v))) {
                            return false;
                        }
                    }
                } else if (l.b == v) {
                    if (pointOnLineLeft(u, Line(l.b, l.a))) {
                        if (pointOnLineLeft(w, Line(l.b, l.a))
                            && pointOnLineLeft(w, Line(u, v))) {
                            return false;
                        }
                    } else {
                        if (pointOnLineLeft(w, Line(l.b, l.a))
                            || pointOnLineLeft(w, Line(u, v))) {
                            return false;
                        }
                    }
                } else {
                    if (pointOnLineLeft(u, l)) {
                        if (pointOnLineLeft(w, Line(l.b, l.a))
                            || pointOnLineLeft(w, Line(u, v))) {
                            return false;
                        }
                    } else {
                        if (pointOnLineLeft(w, l)
                            || pointOnLineLeft(w, Line(u, v))) {
                            return false;
                        }
                    }
                }
            }
        }
    }
    return true;
}
 
template<class T>
std::vector<Point<T>> hp(std::vector<Line<T>> lines) {
    // 对半平面进行排序，排序的规则是：若两个半平面的方向不同，则以方向为正的优先
    // 若两个半平面的方向相同，则以法向量的叉积为正的优先
    std::sort(lines.begin(), lines.end(), [&](auto l1, auto l2) {
        auto d1 = l1.b - l1.a;
        auto d2 = l2.b - l2.a;
         
        if (sgn(d1) != sgn(d2)) {
            return sgn(d1) == 1;
        }
         
        return cross(d1, d2) > 0;
    });
    
    // 定义两个双端队列，ls 存储半平面，ps 存储半平面交的点
    std::deque<Line<T>> ls;
    std::deque<Point<T>> ps;
    // 对每一个半平面进行操作
    for (auto l : lines) {
        // 如果 ls 为空，直接将该半平面加入 ls 中
        if (ls.empty()) {
            ls.push_back(l);
            continue;
        }
        
        // 将已经加入到 ps 中的点向左移动，直到该点满足在新的半平面内
        while (!ps.empty() && !pointOnLineLeft(ps.back(), l)) {
            ps.pop_back();
            ls.pop_back();
        }
        
        // 将已经加入到 ps 中的点向右移动，直到该点满足在新的半平面内
        while (!ps.empty() && !pointOnLineLeft(ps[0], l)) {
            ps.pop_front();
            ls.pop_front();
        }
        
        // 如果新的半平面和 ls 中最后一个半平面的法向量平行，则需要判断它们是否同向
        if (cross(l.b - l.a, ls.back().b - ls.back().a) == 0) {
            // 如果它们同向，则用新的半平面替换原来的半平面
            if (dot(l.b - l.a, ls.back().b - ls.back().a) > 0) {
                 
                if (!pointOnLineLeft(ls.back().a, l)) {
                    assert(ls.size() == 1);
                    ls[0] = l;
                }
                continue;
            }
            // 如果它们不同向，则半平面交不存在，返回空 vector
            return {};
        }
        
        // 计算新的半平面和 ls 中最后一个半平面的交点，并将其加入 ps 中
        ps.push_back(lineIntersection(ls.back(), l));
        ls.push_back(l);
    }
    
    // 将已经加入到 ps 中的点向左移动，直到该点满足在 ls 中的第一个半平面内
    while (!ps.empty() && !pointOnLineLeft(ps.back(), ls[0])) {
        ps.pop_back();
        ls.pop_back();
    }
    // 如果 ls 中的半平面数量小于等于 2，则半平面交不存在，返回空 vector
    if (ls.size() <= 2) {
        return {};
    }
    // 计算 ls 中第一个半平面和最后一个半平面的交点，并将其加入 ps 中
    ps.push_back(lineIntersection(ls[0], ls.back()));
    // 返回 ps 中的点
    return std::vector(ps.begin(), ps.end());
}

```

### 杜老师版本

```cpp
const double EPS = 1e-9;
  
inline int sign(double a) { return a < -EPS ? -1 : a > EPS; }
inline int cmp(double a, double b){ return sign(a-b); }

struct P {
    double x, y;
    P() {}
    P(double _x, double _y) : x(_x), y(_y) {}
    P operator+(P p) { return {x + p.x, y + p.y}; }
    P operator-(P p) { return {x - p.x, y - p.y}; }
    P operator*(double d) { return {x * d, y * d}; }
    P operator/(double d) { return {x / d, y / d}; }
 
    bool operator<(P p) const { 
        int c = cmp(x, p.x);
        if (c) return c == -1;
        return cmp(y, p.y) == -1;
    }
 
    bool operator==(P o) const{
        return cmp(x,o.x) == 0 && cmp(y,o.y) == 0;
    }
 
    double dot(P p) { return x * p.x + y * p.y; }
    double det(P p) { return x * p.y - y * p.x; }
     
    double distTo(P p) { return (*this-p).abs(); }
    double alpha() { return atan2(y, x); }
    void read() { std::cin >> x >>y; }
    void write() {std::cout << "(" << x << "," << y << ")" << std::endl;}
    double abs() { return sqrt(abs2());}
    double abs2() { return x * x + y * y; }
    P rot90() { return P(-y,x);}
    P unit() { return *this/abs(); }
    int quad() const { return sign(y) == 1 || (sign(y) == 0 && sign(x) >= 0); }
    P rot(double an){ return {x*cos(an)-y*sin(an),x*sin(an) + y*cos(an)}; }
};
  
struct L{ //ps[0] -> ps[1]
    P ps[2];
    P& operator[](int i) { return ps[i]; }
    P dir() { return ps[1] - ps[0]; }
    L (P a,P b) {
        ps[0]=a;
        ps[1]=b;
    }
    bool include(P p) { return sign((ps[1] - ps[0]).det(p - ps[0])) > 0; }
    L push(){ // push eps outward
        const double eps = 1e-8;
        P delta = (ps[1] - ps[0]).rot90().unit() * eps;
        return {ps[0] + delta, ps[1] + delta};
    }
};

#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))
#define crossOp(p1,p2,p3) sign(cross(p1,p2,p3))
  
bool chkLL(P p1, P p2, P q1, P q2) {
    double a1 = cross(q1, q2, p1), a2 = -cross(q1, q2, p2);
    return sign(a1+a2) != 0;
}
 
P isLL(P p1, P p2, P q1, P q2) {
    double a1 = cross(q1, q2, p1), a2 = -cross(q1, q2, p2);
    return (p1 * a2 + p2 * a1) / (a1 + a2);
}
  
P isLL(L l1,L l2){ return isLL(l1[0],l1[1],l2[0],l2[1]); }
  
bool intersect(double l1,double r1,double l2,double r2){
    if(l1>r1) std::swap(l1,r1); if(l2>r2) std::swap(l2,r2); 
    return !( cmp(r1,l2) == -1 || cmp(r2,l1) == -1 );
}
  
bool isSS(P p1, P p2, P q1, P q2){
    return intersect(p1.x,p2.x,q1.x,q2.x) && intersect(p1.y,p2.y,q1.y,q2.y) && 
    crossOp(p1,p2,q1) * crossOp(p1,p2,q2) <= 0 && crossOp(q1,q2,p1)
            * crossOp(q1,q2,p2) <= 0;
}
  
bool isSS_strict(P p1, P p2, P q1, P q2){
    return crossOp(p1,p2,q1) * crossOp(p1,p2,q2) < 0 && crossOp(q1,q2,p1)
            * crossOp(q1,q2,p2) < 0;
}
  
bool isMiddle(double a, double m, double b) {
    return sign(a - m) == 0 || sign(b - m) == 0 || (a < m != b < m);
}
  
bool isMiddle(P a, P m, P b) {
    return isMiddle(a.x, m.x, b.x) && isMiddle(a.y, m.y, b.y);
}
  
bool onSeg(P p1, P p2, P q){
    return crossOp(p1,p2,q) == 0 && isMiddle(p1, q, p2);
}
 
bool onSeg_strict(P p1, P p2, P q){
    return crossOp(p1,p2,q) == 0 && sign((q-p1).dot(p1-p2)) * sign((q-p2).dot(p1-p2)) < 0;
}
  
P proj(P p1, P p2, P q) {
    P dir = p2 - p1;
    return p1 + dir * (dir.dot(q - p1) / dir.abs2());
}
  
P reflect(P p1, P p2, P q){
    return proj(p1,p2,q) * 2 - q;
}
  
double nearest(P p1,P p2,P q){
    if (p1==p2) return p1.distTo(q);
    // P h = proj(p1,p2,q);
    // if(isMiddle(p1,h,p2))
    //     return q.distTo(h);
    P dir = p2-p1;
    if (dir.dot(q-p1) < 0 || dir.dot(q-p2) > 0)
       return std::min(p1.distTo(q),p2.distTo(q));
    return std::abs(dir.det(q-p1)) / dir.abs();
}
  
double disSS(P p1, P p2, P q1, P q2){
    if(isSS(p1,p2,q1,q2)) return 0;
    return std::min(std::min(nearest(p1,p2,q1),nearest(p1,p2,q2)), std::min(nearest(q1,q2,p1),nearest(q1,q2,p2)));
}
  
double rad(P p1,P p2){
    return atan2l(p1.det(p2),p1.dot(p2));
}
  
double incircle(P p1, P p2, P p3){
    double A = p1.distTo(p2);
    double B = p2.distTo(p3);
    double C = p3.distTo(p1);
    return sqrtl(A*B*C/(A+B+C));
}
  
//polygon
  
double area(std::vector<P> ps){ 
    double ret = 0; for (int i = 0; i < ps.size(); ++i) ret += ps[i].det(ps[(i+1)%ps.size()]); 
    return ret/2;
}
  
int contain(std::vector<P> ps, P p){ //2:inside,1:on_seg,0:outside
    int n = ps.size(), ret = 0; 
    for (int i = 0; i < n; ++i){
        P u=ps[i],v=ps[(i+1)%n];
        if(onSeg(u,v,p)) return 1;
        if(cmp(u.y,v.y)<=0) std::swap(u,v);
        if(cmp(p.y,u.y) >0 || cmp(p.y,v.y) <= 0) continue;
        ret ^= crossOp(p,u,v) > 0;
    }
    return ret*2;
}
  
std::vector<P> convexHull(std::vector<P> ps) {
    int n = ps.size(); if(n <= 1) return ps;
    std::sort(ps.begin(), ps.end());
    std::vector<P> qs(n * 2); int k = 0;
    for (int i = 0; i < n; qs[k++] = ps[i++]) 
        while (k > 1 && crossOp(qs[k - 2], qs[k - 1], ps[i]) <= 0) --k;
    for (int i = n - 2, t = k; i >= 0; qs[k++] = ps[i--])
        while (k > t && crossOp(qs[k - 2], qs[k - 1], ps[i]) <= 0) --k;
    qs.resize(k - 1);
    return qs;
}
  
std::vector<P> convexHullNonStrict(std::vector<P> ps) {
    //caution: need to unique the Ps first
    int n = ps.size(); if(n <= 1) return ps;
    std::sort(ps.begin(), ps.end());
    std::vector<P> qs(n * 2); int k = 0;
    for (int i = 0; i < n; qs[k++] = ps[i++]) 
        while (k > 1 && crossOp(qs[k - 2], qs[k - 1], ps[i]) < 0) --k;
    for (int i = n - 2, t = k; i >= 0; qs[k++] = ps[i--])
        while (k > t && crossOp(qs[k - 2], qs[k - 1], ps[i]) < 0) --k;
    qs.resize(k - 1);
    return qs;
}
  
double convexDiameter(std::vector<P> ps){
    int n = ps.size(); if(n <= 1) return 0;
    int is = 0, js = 0; for (int k = 1; k < n; ++k) is = ps[k]<ps[is]?k:is, js = ps[js] < ps[k]?k:js;
    int i = is, j = js;
    double ret = ps[i].distTo(ps[j]);
    do{
        if((ps[(i+1)%n]-ps[i]).det(ps[(j+1)%n]-ps[j]) >= 0)
            (++j)%=n;
        else
            (++i)%=n;
        ret = std::max(ret,ps[i].distTo(ps[j]));
    }while(i!=is || j!=js);
    return ret;
}
  
std::vector<P> convexCut(const std::vector<P>&ps, P q1, P q2) {
    std::vector<P> qs;
    int n = ps.size();
    for (int i = 0; i < n; ++i){
        P p1 = ps[i], p2 = ps[(i+1)%n];
        int d1 = crossOp(q1,q2,p1), d2 = crossOp(q1,q2,p2);
        if(d1 >= 0) qs.push_back(p1);
        if(d1 * d2 < 0) qs.push_back(isLL(p1,p2,q1,q2));
    }
    return qs;
}
  
//min_dist
  
double min_dist(std::vector<P>&ps,int l,int r){
    if(r-l<=5){
        double ret = 1e100;
        for (int i = l; i < r; ++i) for (int j = l; j < i; ++j) ret = std::min(ret,ps[i].distTo(ps[j]));
        return ret;
    }
    int m = (l+r)>>1;
    double ret = std::min(min_dist(ps,l,m),min_dist(ps,m,r));
    std::vector<P> qs; for (int i = l; i < r; ++i) if(abs(ps[i].x-ps[m].x)<= ret) qs.push_back(ps[i]);
    std::sort(qs.begin(), qs.end(), [](P a,P b) -> bool {return a.y < b.y; });
    for (int i = 1; i < qs.size(); ++i) for(int j = i-1; j >= 0 && qs[j].y >= qs[i].y-ret; --j)
        ret = std::min(ret, qs[i].distTo(qs[j]));
    return ret;
}
  
int type(P o1,double r1,P o2,double r2){
    double d = o1.distTo(o2);
    if(cmp(d,r1+r2) == 1) return 4;
    if(cmp(d,r1+r2) == 0) return 3;
    if(cmp(d,abs(r1-r2)) == 1) return 2;
    if(cmp(d,abs(r1-r2)) == 0) return 1;
    return 0;
}
  
std::vector<P> isCL(P o,double r,P p1,P p2){
    if (cmp(abs((o-p1).det(p2-p1)/p1.distTo(p2)),r)>0) return {};
    double x = (p1-o).dot(p2-p1), y = (p2-p1).abs2(), d = x * x - y * ((p1-o).abs2() - r*r);
    d = std::max(d,(double)0.0); P m = p1 - (p2-p1)*(x/y), dr = (p2-p1)*(sqrt(d)/y);
    return {m-dr,m+dr}; //along dir: p1->p2
}
  
std::vector<P> isCC(P o1, double r1, P o2, double r2) { //need to check whether two circles are the same
    double d = o1.distTo(o2); 
    if (cmp(d, r1 + r2) == 1) return {};
    if (cmp(d,abs(r1-r2))==-1) return {};
    d = std::min(d, r1 + r2);
    double y = (r1 * r1 + d * d - r2 * r2) / (2 * d), x = sqrt(r1 * r1 - y * y);
    P dr = (o2 - o1).unit();
    P q1 = o1 + dr * y, q2 = dr.rot90() * x;
    return {q1-q2,q1+q2};//along circle 1
}
  
std::vector<P> tanCP(P o, double r, P p) {
    double x = (p - o).abs2(), d = x - r * r;
    if (sign(d) <= 0) return {}; // on circle => no tangent
    P q1 = o + (p - o) * (r * r / x);
    P q2 = (p - o).rot90() * (r * sqrt(d) / x);
    return {q1-q2,q1+q2}; //counter clock-wise
}
  
  
std::vector<L> extanCC(P o1, double r1, P o2, double r2) {
    std::vector<L> ret;
    if (cmp(r1, r2) == 0) {
        P dr = (o2 - o1).unit().rot90() * r1;
        ret.push_back(L(o1 + dr, o2 + dr)), ret.push_back(L(o1 - dr, o2 - dr));
    } else {
        P p = (o2 * r1 - o1 * r2) / (r1 - r2);
        std::vector<P> ps = tanCP(o1, r1, p), qs = tanCP(o2, r2, p);
        for (int i = 0; i < std::min(ps.size(),qs.size()); ++i) ret.push_back(L(ps[i], qs[i])); //c1 counter-clock wise
    }
    
    return ret;
}
  
std::vector<L> intanCC(P o1, double r1, P o2, double r2) {
    std::vector<L> ret;
    P p = (o1 * r2 + o2 * r1) / (r1 + r2);
    std::vector<P> ps = tanCP(o1,r1,p), qs = tanCP(o2,r2,p);
    for (int i = 0; i < std::min(ps.size(),qs.size()); ++i) ret.push_back(L(ps[i], qs[i])); //c1 counter-clock wise
    return ret;
}
  
double areaCT(double r, P p1, P p2){
    std::vector<P> is = isCL(P(0,0),r,p1,p2);
    if(is.empty()) return r*r*rad(p1,p2)/2;
    bool b1 = cmp(p1.abs2(),r*r) == 1, b2 = cmp(p2.abs2(), r*r) == 1;
    if(b1 && b2){
        if(sign((p1-is[0]).dot(p2-is[0])) <= 0 &&
            sign((p1-is[0]).dot(p2-is[0])) <= 0)
        return r*r*(rad(p1,is[0]) + rad(is[1],p2))/2 + is[0].det(is[1])/2;
        else return r*r*rad(p1,p2)/2;
    }
    if(b1) return (r*r*rad(p1,is[0]) + is[0].det(p2))/2;
    if(b2) return (p1.det(is[1]) + r*r*rad(is[1],p2))/2;
    return p1.det(p2)/2;
}
  
bool parallel(L l0, L l1) { return sign( l0.dir().det( l1.dir() ) ) == 0; }
  
bool sameDir(L l0, L l1) { return parallel(l0, l1) && sign(l0.dir().dot(l1.dir()) ) == 1; }
  
bool cmp (P a,  P b) {
    if (a.quad() != b.quad()) {
        return a.quad() < b.quad();
    } else {
        return sign( a.det(b) ) > 0;
    }
}
  
bool operator < (L l0, L l1) {
    if (sameDir(l0, l1)) {
        return l1.include(l0[0]);
    } else {
        return cmp( l0.dir(), l1.dir() );
    }
}
  
bool check(L u, L v, L w) { 
    return w.include(isLL(u,v)); 
}
  
std::vector<P> halfPlaneIS(std::vector<L> &l) {
    std::sort(l.begin(), l.end());
    std::deque<L> q;
    for (int i = 0; i < (int)l.size(); ++i) {
        if (i && sameDir(l[i], l[i - 1])) continue;
        while (q.size() > 1 && !check(q[q.size() - 2], q[q.size() - 1], l[i])) q.pop_back();
        while (q.size() > 1 && !check(q[1], q[0], l[i])) q.pop_front();
        q.push_back(l[i]);
    }
    while (q.size() > 2 && !check(q[q.size() - 2], q[q.size() - 1], q[0])) q.pop_back();
    while (q.size() > 2 && !check(q[1], q[0], q[q.size() - 1])) q.pop_front();
    std::vector<P> ret;
    for (int i = 0; i < (int)q.size(); ++i) ret.push_back(isLL(q[i], q[(i + 1) % q.size()]));
    return ret;
}
 
P inCenter(P A, P B, P C) {
    double a = (B - C).abs(), b = (C - A).abs(), c = (A - B).abs();
    return (A * a + B * b + C * c) / (a + b + c);
}
 
P circumCenter(P a, P b, P c) { 
    P bb = b - a, cc = c - a;
    double db = bb.abs2(), dc = cc.abs2(), d = 2 * bb.det(cc);
    return a - P(bb.y * dc - cc.y * db, cc.x * db - bb.x * dc) / d;
}
 
P othroCenter(P a, P b, P c) { 
    P ba = b - a, ca = c - a, bc = b - c;
    double Y = ba.y * ca.y * bc.y,
    A = ca.x * ba.y - ba.x * ca.y,
    x0 = (Y + ca.x * ba.y * b.x - ba.x * ca.y * c.x) / A,
    y0 = -ba.x * (x0 - c.x) / ba.y + ca.y;
    return {x0, y0};
}

```


