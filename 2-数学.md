# 数学

## 数论

### 数论整数

```cpp
constexpr int P = 998244353;
// assume -P <= x < 2P
int norm(int x) {
    // x %= P;
    if (x < 0) { x += P; }
    if (x >= P) { x -= P; }
    return x;
}
template<typename E>
E power(E n, int k) {
    E ret = E(1);
    while (k) {
        if (k & 1) ret *= n;
        n *= n;
        k >>= 1;
    } return ret;
}
struct Z {
    int x;
    Z(int x = 0) : x(norm(x)) {}
    int val() const { return x; }
    Z operator-() const { return Z(norm(P - x)); }
    Z inv() const { assert(x != 0); return power(*this, P - 2); }
    Z &operator*=(const Z &rhs) { x = (long long)(x) * rhs.x % P; return *this; }
    Z &operator+=(const Z &rhs) { x = norm(x + rhs.x); return *this; }
    Z &operator-=(const Z &rhs) { x = norm(x - rhs.x); return *this; }
    Z &operator/=(const Z &rhs) { return *this *= rhs.inv(); }
    friend Z operator*(const Z &lhs, const Z &rhs) { Z res = lhs; res *= rhs; return res; }
    friend Z operator+(const Z &lhs, const Z &rhs) { Z res = lhs; res += rhs; return res; }
    friend Z operator-(const Z &lhs, const Z &rhs) { Z res = lhs; res -= rhs; return res; }
    friend Z operator/(const Z &lhs, const Z &rhs) { Z res = lhs; res /= rhs; return res; }
    friend std::istream &operator>>(std::istream &is, Z &a) { long long v; is >> v; a = Z(v); return is; }
    friend std::ostream &operator<<(std::ostream &os, const Z &a) { return os << a.val(); }
};
```

### 拉格朗日差值法

### 欧几里得

+ 扩展欧几里得

```cpp
int exgcd(int a, int b, int& x, int& y) {
    if (a == 0) {
        x = 0, y = 1;
        return b;
    }
    int ret = exgcd(b % a, a, x, y), xx = x;
    x = y - b / a * x;
    y = xx; 
    return ret;
}
```

#### 类欧几里得

+ $m = \lfloor \frac{an+b}{c} \rfloor$ .
+ $f(a,b,c,n)=\sum_{i=0}^n\lfloor\frac{ai+b}{c}\rfloor$ : 当 $a \ge c$ or $b \ge c$ 时, $f(a,b,c,n)=(\frac{a}{c})n(n+1)/2+(\frac{b}{c})(n+1)+f(a \bmod c,b \bmod c,c,n)$ ; 否则 $f(a,b,c,n)=nm-f(c,c-b-1,a,m-1)$ 。
+ $g(a,b,c,n)=\sum_{i=0}^n i \lfloor\frac{ai+b}{c}\rfloor$ : 当 $a \ge c$ or $b \ge c$ 时, $g(a,b,c,n)=(\frac{a}{c})n(n+1)(2n+1)/6+(\frac{b}{c})n(n+1)/2+g(a \bmod c,b \bmod c,c,n)$ ; 否则 $g(a,b,c,n)=\frac{1}{2} (n(n+1)m-f(c,c-b-1,a,m-1)-h(c,c-b-1,a,m-1))$ 。
+ $h(a,b,c,n)=\sum_{i=0}^n\lfloor \frac{ai+b}{c} \rfloor^2$ : 当 $a \ge c$ or $b \ge c$ 时, $h(a,b,c,n)=(\frac{a}{c})^2 n(n+1)(2n+1)/6 +(\frac{b}{c})^2 (n+1)+(\frac{a}{c})(\frac{b}{c})n(n+1)+h(a \bmod c, b \bmod c,c,n)+2(\frac{a}{c})g(a \bmod c,b \bmod c,c,n)+2(\frac{b}{c})f(a \bmod c,b \bmod c,c,n)$ ; 否则 $h(a,b,c,n)=nm(m+1)-2g(c,c-b-1,a,m-1)-2f(c,c-b-1,a,m-1)-f(a,b,c,n)$ 。


```cpp

template<typename T>
T lintp(const vector<int>& x, const vector<T>& y, int k) {
    T ans = 0;
    for (int i = 0; i < x.size(); ++i) {
        if (k == x[i])
            return y[i];
        T u = 1, v = 1;
        for (int j = 0; j < x.size(); ++j) {
            if (i == j) continue;
            u *= (k - x[j]);
            v *= (x[i] - x[j]);
        }
        ans += y[i] * u / v;
    }
    return ans;
}

```

### 中国剩余定理

```cpp
int CRT(std::vector<int> a, std::vector<int> r) {
    long long n = 1, ans = 0, k = a.size();
    for (int i = 0; i < k; ++i) n = n * r[i];
    for (int i = 0; i < k; ++i) {
        long long m = n / r[i], b, y;
        exgcd(m, r[i], b, y);
        ans = (ans + a[i] * m % n * b % n + n) % n;
    }
    return ans;
}

```

### 各种筛

| 筛法 | 场景 | 效率 |
| --- | --- | --- |
| Min-25筛 | $f(p)$ 是一个关于 $p$ 的多项式, $f(p^c)$ 能快速求 | $O(\frac{n^{\frac{3}{4}}} {\log n})$ |
| PN筛 | 找一个好求前缀和的积性函数 $g()$ 在 $p$ 处 $f(p) = g(p)$ | $O(\sqrt{n})$ |
| 杜教筛 | 找一个 $g()$ 使得 $f*g()$ 好求前缀和 | $O(n^{\frac{2}{3}})$ |

#### Min-25筛

$$
\begin{aligned}
    F_{k}(n)
    &= \sum_{i = 2}^{n} [p_{k} \le \operatorname{lpf}(i)] f(i) \\
    &= \sum_{\substack{k \le i \\ p_{i}^{2} \le n}} \sum_{\substack{c \ge 1 \\ p_{i}^{c} \le n}} f\left(p_{i}^{c}\right) ([c > 1] + F_{i + 1}\left(n / p_{i}^{c}\right)) + \sum_{\substack{k \le i \\ p_{i} \le n}} f(p_{i}) \\
    &= \sum_{\substack{k \le i \\ p_{i}^{2} \le n}} \sum_{\substack{c \ge 1 \\ p_{i}^{c} \le n}} f\left(p_{i}^{c}\right) ([c > 1] + F_{i + 1}\left(n / p_{i}^{c}\right)) + F_{\mathrm{prime}}(n) - F_{\mathrm{prime}}(p_{k - 1}) \\
    &= \sum_{\substack{k \le i \\ p_{i}^{2} \le n}} \sum_{\substack{c \ge 1 \\ p_{i}^{c + 1} \le n}} \left(f\left(p_{i}^{c}\right) F_{i + 1}\left(n / p_{i}^{c}\right) + f\left(p_{i}^{c + 1}\right)\right) + F_{\mathrm{prime}}(n) - F_{\mathrm{prime}}(p_{k - 1})
\end{aligned}
$$
$$
G_{k}(n) = G_{k - 1}(n) - \left[p_{k}^{2} \le n\right] g(p_{k}) (G_{k - 1}(n / p_{k}) - G_{k - 1}(p_{k - 1}))
$$

```cpp
namespace Min_25{
    bool INI = 0;
    int M = 0, sqn = 0;
    std::vector<int> primes;
    Z (*fp)(int, int);  // f(p^c)
    Z fp_single(int p, int c) {
        return power(Z(p), c);
    }
    Z sgp(int n, int c) {
        if (c == 0) return Z(n);
        if (c == 1) return Z(n+ 1) * n / 2;
        if (c == 2) return Z(2*n+1) * (n+1) * n / 6;
        // if (c == 3) return Z(n) * n * (n+1) * (n+1) / 4;
        // if (c == 4) return Z(n) * (n+1) * (2*n+1) * (3*n*n%P + 3*n - 1) / 30;
    }
    struct Gpoly{
        int M, sqn, a;
        std::vector<Z> F_prime1, F_prime2;
        Gpoly(int scale, int a, int c): M(scale), a(a) {
            sqn = sqrt(M) + 3; 
            F_prime1.resize(sqn), F_prime2.resize(sqn);

            int st = M, ed = 1;
            for (int i = 1; st >= ed; st = min(M / ++i, st - 1)) {
                (*this)[st] = sgp(st, c) - 1;
            }
            for (int j = 1; j < primes.size(); ++j) {
                st = M, ed = primes[j] * primes[j];
                for (int i = 1; st >= ed; st = min(M / ++i, st - 1)) {
                    (*this)[st] -= fp_single(primes[j], c) * ((*this)[st/primes[j]] - (*this)[primes[j-1]]);
                }
            }
        }
        void seta(int aa) {a = aa;}
        Z & operator [](int idx) {
            if (idx < sqn) return F_prime1[idx];
            return F_prime2[M/idx];
        }
    };

    std::vector<Gpoly> Gp;
    Z G(int x){
        Z res = 0;
        for (auto &g: Gp) res += g[x] * g.a;
        return res;
    }
    void init(int scale) {
        if (M < scale) INI = 0;
        M = scale, sqn = sqrt(M) + 5;
        
        if (!INI) {
            INI = 1;
            std::vector<signed> vis(sqn);
            primes.resize(1, 1);
            for (int i = 2; i < sqn; ++i) {
                if (!vis[i]) primes.push_back(i);
                for (int j = 1; j < primes.size(); ++j) {
                    auto prm = primes[j];
                    if (prm * i >= sqn) break;
                    vis[i * prm] = 1;
                    if (i % prm == 0) break; 
                }
            }

        }

        Gp.clear();
        Gp.emplace_back(scale, N, 0);
        // Gp.emplace_back(scale, a, c); // a*p^c
    }
    Z seive(int n, int k) {
        Z res = G(n) - G(primes[k-1]);
        for (int i = k; i < primes.size() && primes[i] * primes[i] <= n; ++i) {
            Z fpj = fp(primes[i], 1), fpj1;
            for (int j = 1, pc = primes[i]; pc * primes[i] <= n; ++j, pc *= primes[i], fpj = fpj1) {
                fpj1 = fp(primes[i], j + 1);
                res += fpj * seive(n/pc, i + 1) + fpj1;
            }
        }
        return res;
    }
    Z S_f(int n) {
        return seive(n, 1) + 1;
    }
    void seta(const vector<int>& a) {for (int i = 0; i < Gp.size() && i < a.size(); ++i) Gp[i].seta(a[i]);}
}

```

#### PN筛(Powerful Number)

```cpp

// f = (g*h); f(p) = g(p) + h(p) [with f(p) = g(p)] -> h[p] = 0.
namespace PowerfulNumber{
    bool INI = 0;
    std::vector<int> primes;
    std::vector<std::vector<Z> > h;
    int M;
    Z (*fp)(int, int);  // f(p^c)
    Z (*gp)(int, int);  // g(p^c)
    Z (*S_g)(int);      // preffix sum of g()

    // if lack of a formula of h(i, j), you need to set f() and g() beforehand
    void init(int scale) {
        if (M < scale) INI = 0;
        M = scale;
        int n = std::sqrt(M)+10;
        if (!INI) {
            INI = 1;
            primes.resize(0);
            std::vector<signed> vis(n);
            for (int i = 2; i < n; ++i) {
                if (!vis[i]) primes.push_back(i);
                for (auto prm: primes) {
                    if (prm * i >= n) break;
                    vis[i * prm] = 1;
                    if (i % prm == 0) break; 
                }
            }
            h.resize(primes.size(), std::vector<Z>((int)(log2(M))+1));
        }

        // get the function h() (with f() and g() set or with formula of h())
        for (int i = 0; i < h.size(); ++i) {
            int pp = primes[i] * primes[i];
            if (pp > M) break;
            h[i][0] = 1;
            for (int j = 2; pp <= M && j < h[i].size(); ++j, pp *= primes[i]) {
                Z sgh = 0;
                for (int k = 1, xp = primes[i]; k <= j; ++k, xp *= primes[i]) {
                    sgh += gp(primes[i], xp) * h[i][j-k];
                }
                h[i][j] = fp(pp, j) - sgh;
                // h[i][j] = Z(j-1) * (pp * primes[i] % P - pp % P);
                // h[i][j] = Z(-pp) / (j * (j-1));
                // [a formula of h(i, j)], better faster than log, this example can be optimized to O(1).
            }
        }
    }

    // assistance func to get the sum
    Z PN_sieve(int n, int flr, Z hd) {
        Z res = S_g(n)*hd;
        for(int i = flr+1; i < primes.size(); ++i) {
            int prm=primes[i], k=1;
            int val=n/prm, pk=prm;

            if(val < prm) break;
            while(val >= prm) {
                val /= prm;
                pk *= prm;
                ++k;
                
                res += PN_sieve(val, i, hd*h[i][k]);
            }
        }
        return res;
    }
    // func to get the sum
    Z getsumf(int n) {
        return PN_sieve(n, -1, 1);
    }
}

```

#### 杜教筛

```cpp
// g(1)S(n) = \sum_{i=1}^{n}(f*g)(i) - \sum_{i=2}^{n}g(i)S(n/i)
namespace dujiaoshai{
    vector<Z> smallS;
    map<int, Z> bigS;

    void Set_smallS(int);
    Z (*S_fg)(int);
    Z (*S_g)(int);
    Z getS(int n) {
        if (n < smallS.size())  return smallS[n];
        else if (bigS.count(n)) return bigS[n];
        Z res = S_fg(n);
        for (int l = 2, r; l <= n; l = r + 1) {
            r = n / (n / l);
            res -= (S_g(r) - S_g(l-1)) * getS(n/l);
        }
        // res /= S_g(1);
        return (bigS[n] = res);
    }
}

void dujiaoshai::Set_smallS(int siz) {
    int n = pow(siz, 0.67);
    smallS.assign(n, 0);
    smallS[1] = 1;
    vector<signed> vis(n), primes;
    for (int i = 2; i < n; ++i) {
        if (!vis[i]) {
            primes.push_back(i);
            smallS[i] = i - 1;
        }
        for (auto &prm: primes) {
            if (i * prm >= n) break;
            vis[i * prm] = 1;
            if (i % prm == 0) {
                smallS[i * prm] = smallS[i] * prm;
                break;
            }
            smallS[i * prm] = smallS[i] * (prm - 1);
        }
        smallS[i] = smallS[i-1] + smallS[i]*i;
    }
}
```

### 多项式

+ Poly with NTT

```cpp

std::vector<int> rev;
std::vector<Z> roots{0, 1};
void dft(std::vector<Z> &a) {
    int n = a.size();
    
    if ((int)(rev.size()) != n) {
        int k = __builtin_ctz(n) - 1;
        rev.resize(n);
        for (int i = 0; i < n; i++) {
            rev[i] = rev[i >> 1] >> 1 | (i & 1) << k;
        }
    }
    
    for (int i = 0; i < n; i++) {
        if (rev[i] < i) {
            std::swap(a[i], a[rev[i]]);
        }
    }
    if ((int)(roots.size()) < n) {
        int k = __builtin_ctz(roots.size());
        roots.resize(n);
        while ((1 << k) < n) {
            Z e = power(Z(3), (P - 1) >> (k + 1));
            for (int i = 1 << (k - 1); i < (1 << k); i++) {
                roots[2 * i] = roots[i];
                roots[2 * i + 1] = roots[i] * e;
            }
            k++;
        }
    }
    for (int k = 1; k < n; k *= 2) {
        for (int i = 0; i < n; i += 2 * k) {
            for (int j = 0; j < k; j++) {
                Z u = a[i + j];
                Z v = a[i + j + k] * roots[k + j];
                a[i + j] = u + v;
                a[i + j + k] = u - v;
            }
        }
    }
}
void idft(std::vector<Z> &a) {
    int n = a.size();
    std::reverse(a.begin() + 1, a.end());
    dft(a);
    Z inv = (1 - P) / n;
    for (int i = 0; i < n; i++) {
        a[i] *= inv;
    }
}
struct Poly {
    std::vector<Z> a;
    Poly() {}
    Poly(const std::vector<Z> &a) : a(a) {}
    Poly(const std::initializer_list<Z> &a) : a(a) {}
    int size() const {
        return a.size();
    }
    void resize(int n) {
        a.resize(n);
    }
    Z operator[](int idx) const {
        if (idx < size()) {
            return a[idx];
        } else {
            return 0;
        }
    }
    Z &operator[](int idx) {
        return a[idx];
    }
    Poly mulxk(int k) const {
        auto b = a;
        b.insert(b.begin(), k, 0);
        return Poly(b);
    }
    Poly modxk(int k) const {
        k = std::min(k, size());
        return Poly(std::vector<Z>(a.begin(), a.begin() + k));
    }
    Poly divxk(int k) const {
        if (size() <= k) {
            return Poly();
        }
        return Poly(std::vector<Z>(a.begin() + k, a.end()));
    }
    friend Poly operator+(const Poly &a, const Poly &b) {
        std::vector<Z> res(std::max(a.size(), b.size()));
        for (int i = 0; i < (int)(res.size()); i++) {
            res[i] = a[i] + b[i];
        }
        return Poly(res);
    }
    friend Poly operator-(const Poly &a, const Poly &b) {
        std::vector<Z> res(std::max(a.size(), b.size()));
        for (int i = 0; i < (int)(res.size()); i++) {
            res[i] = a[i] - b[i];
        }
        return Poly(res);
    }
    friend Poly operator*(Poly a, Poly b) {
        if (a.size() == 0 || b.size() == 0) {
            return Poly();
        }
        int sz = 1, tot = a.size() + b.size() - 1;
        while (sz < tot) {
            sz *= 2;
        }
        a.a.resize(sz);
        b.a.resize(sz);
        dft(a.a);
        dft(b.a);
        for (int i = 0; i < sz; ++i) {
            a.a[i] = a[i] * b[i];
        }
        idft(a.a);
        a.resize(tot);
        return a;
    }
    friend Poly operator*(Z a, Poly b) {
        for (int i = 0; i < (int)(b.size()); i++) {
            b[i] *= a;
        }
        return b;
    }
    friend Poly operator*(Poly a, Z b) {
        for (int i = 0; i < (int)(a.size()); i++) {
            a[i] *= b;
        }
        return a;
    }
    Poly &operator+=(Poly b) {
        return (*this) = (*this) + b;
    }
    Poly &operator-=(Poly b) {
        return (*this) = (*this) - b;
    }
    Poly &operator*=(Poly b) {
        return (*this) = (*this) * b;
    }
    Poly deriv() const {
        if (a.empty()) {
            return Poly();
        }
        std::vector<Z> res(size() - 1);
        for (int i = 0; i < size() - 1; ++i) {
            res[i] = (i + 1) * a[i + 1];
        }
        return Poly(res);
    }
    Poly integr() const {
        std::vector<Z> res(size() + 1);
        for (int i = 0; i < size(); ++i) {
            res[i + 1] = a[i] / (i + 1);
        }
        return Poly(res);
    }
    Poly inv(int m) const {
        Poly x{a[0].inv()};
        int k = 1;
        while (k < m) {
            k *= 2;
            x = (x * (Poly{2} - modxk(k) * x)).modxk(k);
        }
        return x.modxk(m);
    }
    Poly log(int m) const {
        return (deriv() * inv(m)).integr().modxk(m);
    }
    Poly exp(int m) const {
        Poly x{1};
        int k = 1;
        while (k < m) {
            k *= 2;
            x = (x * (Poly{1} - x.log(k) + modxk(k))).modxk(k);
        }
        return x.modxk(m);
    }
    Poly pow(int k, int m) const {
        int i = 0;
        while (i < size() && a[i].val() == 0) {
            i++;
        }
        if (i == size() || 1LL * i * k >= m) {
            return Poly(std::vector<Z>(m));
        }
        Z v = a[i];
        auto f = divxk(i) * v.inv();
        return (f.log(m - i * k) * k).exp(m - i * k).mulxk(i * k) * power(v, k);
    }
    Poly sqrt(int m) const {
        Poly x{1};
        int k = 1;
        while (k < m) {
            k *= 2;
            x = (x + (modxk(k) * x.inv(k)).modxk(k)) * ((P + 1) / 2);
        }
        return x.modxk(m);
    }
    Poly mulT(Poly b) const {
        if (b.size() == 0) {
            return Poly();
        }
        int n = b.size();
        std::reverse(b.a.begin(), b.a.end());
        return ((*this) * b).divxk(n - 1);
    }
    std::vector<Z> eval(std::vector<Z> x) const {
        if (size() == 0) {
            return std::vector<Z>(x.size(), 0);
        }
        const int n = std::max((int)(x.size()), size());
        std::vector<Poly> q(4 * n);
        std::vector<Z> ans(x.size());
        x.resize(n);
        std::function<void(int, int, int)> build = [&](int p, int l, int r) {
            if (r - l == 1) {
                q[p] = Poly{1, -x[l]};
            } else {
                int m = (l + r) / 2;
                build(2 * p, l, m);
                build(2 * p + 1, m, r);
                q[p] = q[2 * p] * q[2 * p + 1];
            }
        };
        build(1, 0, n);
        std::function<void(int, int, int, const Poly &)> work = [&](int p, int l, int r, const Poly &num) {
            if (r - l == 1) {
                if (l < (int)(ans.size())) {
                    ans[l] = num[0];
                }
            } else {
                int m = (l + r) / 2;
                work(2 * p, l, m, num.mulT(q[2 * p + 1]).modxk(m - l));
                work(2 * p + 1, m, r, num.mulT(q[2 * p]).modxk(r - m));
            }
        };
        work(1, 0, n, mulT(q[1].inv(n)));
        return ans;
    }
};

```

+ FFT

```cpp
namespace FFT { // n_是初始的数组长度, 不一定为2的幂次; n是init之后的长度, 保证为2的幂次长度
    const double PI = acos(-1);
    int rev[1 << 20];
    int init(int n_) {
        int step = 0, n = 1;
        for (; n < n_; n <<= 1) ++step;
        for (int i = 1; i < n; ++i) {
            rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (step - 1));
        }
        return n;
    }
    void FFT(complex<double> a[], int n, int f) {
        for (int i = 0; i < n; ++i) {
            if (i < rev[i]) std::swap(a[i], a[rev[i]]);
        }
        for (int h = 2; h <= n; h <<= 1) {
            complex<double> wn(cos(f * 2 * PI / h), sin(f * 2 * PI / h));
            for (int i = 0; i < n; i += h) {
                complex<double> w(1, 0), u;
                for (int j = i, k = h >> 1; j < i + k; ++j) {
                    u = a[j + k] * w;
                    a[j + k] = a[j] - u;
                    a[j] = a[j] + u;
                    w = w * wn;
                }
            }
        }
        if (f == -1) {
            for (int i = 0; i < n; ++i) {
                a[i] = {a[i].real() / n, 0};
            }
        }
    }
    void conv(complex<double> a[], complex<double> b[], int n_) { // n_ does not represent the pow of 2.
        int n = init(n_);
        FFT(a, n, 1);
        FFT(b, n, 1);
        for (int i = 0; i < n; ++i) a[i] *= b[i];
        FFT(a, n, -1);
    }
}
```

## 组合数学

### 卡特兰数

可以将问题划分为两个子问题的问题, 满足递推式:
$$
H_n = \begin{cases}
    \sum_{i=1}^{n} H_{i-1} H_{n-i} & n \geq 2, n \in \mathbf{N_{+}}\\
    1 & n = 0, 1
\end{cases}
$$

递推式: $H_n = \dfrac{H_{n-1}(4n-2)}{n+1}$
通项式: $H_n = \binom{2n}{n} - \binom{2n}{n-1}$

### 斯特林数

将 $n$ 个不相同的元素划分为 $k$ 个互不区分的集合, $\begin{Bmatrix} n \\ k \end{Bmatrix}$ , 也记作 $S(n, k)$ .

递推式: $S(n,k) = S(n-1,k) + k\times S(n-1, k)$
通项公式: $\begin{Bmatrix} n \\ m \end{Bmatrix} = \sum \limits_{i=0} ^m \dfrac{(-1)^{m-i} i^n}{i! (m-i)!}$

#### 第二类斯特林数

```cpp
struct Stirling2 {
    std::vector<std::vector<Z> > S;
    Stirling2 (int n) {
        S.resize(n+1, vector<Z>(n+1));
        S[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= n; ++j) {
                S[i][j] = S[i-1][j-1] + S[i-1][j] * j;
            }
        }
    }
    std::vector<Z> &operator [](int idx) {return S[idx];}
};


struct Stirling2_oneline {
    std::vector<Z> S;
    int n;
    // S[n][k] = \sum \frac {i^n (-1)^{m-i}}{i! (m-i)!}
    // that is convolution of f(x) = x^n / (x!) and g(x) = (-1)^x / (x!)
    Stirling2_oneline(int _n): n(_n) {
        vector<Z> f(n+1), g(n+1), ifact(n+1);
        g[0] = 1;

        Z fact = 1;
        for (int i = 1; i <= n; ++i) fact *= i;
        ifact[n] = fact.inv();
        for (int i = n-1; i >= 1; --i) {
            ifact[i] = ifact[i+1] * (i+1);
        }

        for (int i = 1; i <= n; ++i) {
            f[i] = power(Z(i), n) * ifact[i];
            g[i] = ifact[i] * (i % 2? -1: 1);
        }

        S = (Poly(f) * Poly(g)).modxk(n+1).a;
    }
    Z operator [](int idx) {return S[idx];}
};

```

### 分拆数

将 $n$ 分成 $k$ 个部分的分拆, 称为 $k$ 部分拆, 记作 $p(n,k)$

递推式: $p(n,k) = p(n-1, k-1) + p(n-k, k)$

### 容斥原理

![集合](assets\incexcp.png)
$|A\cup B\cup C|=|A|+|B|+|C|-|A\cap B|-|B\cap C|-|C\cap A|+|A\cap B\cap C|$

进一步推广:

$$
\begin{split}
\left|\bigcup_{i=1}^{n}S_i\right|=&\sum_{i}|S_i|-\sum_{i<j}|S_i\cap S_j|+\sum_{i<j<k}|S_i\cap S_j\cap S_k|-\cdots\\
&+(-1)^{m-1}\sum_{a_i<a_{i+1} }\left|\bigcap_{i=1}^{m}S_{a_i}\right|+\cdots+(-1)^{n-1}|S_1\cap\cdots\cap S_n|
\end{split}
$$

经典例子: 不定方程非负整数解

## 线性代数

### 线性基

```cpp
struct LinearBase{
    std::vector<int> LBP;
    LinearBase(): LBP(64) {}
    LinearBase(int _n): LBP(_n) {}

    void insert(int x) {
        for (int i = (int)LBP.size() - 1; i >= 0; --i) {
            if ((x >> i) & 1) {
                if (!LBP[i]) {LBP[i] = x; break;}
                else x ^= LBP[i];
            }
            else continue;
        }
    }
    bool query(int x) {
        for (int i = (int)LBP.size() - 1; i >= 0; --i) {
            if ((x >> i) & 1) x ^= LBP[i];
        }
        return (x == 0);
    }
    int MaxSum() {
        int ret = 0;
        for (int i = (int)LBP.size() - 1; i >= 0; --i) {
            if ((ret >> i) & 1) continue;
            else ret ^= LBP[i];
        }
        return ret;
    }
};
```

## 博弈论

Sprague-Grundy Theorem (SG定理), 将多个游戏的SG值异或起来就能表示组合起来的胜负状态. 可以归纳法来证明.
